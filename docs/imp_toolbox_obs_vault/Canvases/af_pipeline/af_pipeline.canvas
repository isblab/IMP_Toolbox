{
	"nodes":[
		{"alias":"get_attribues","collapsed":true,"id":"6db7996ab0c1715d","type":"text","text":"```py\ndef get_attributes(self):\n\t\"\"\"\n\tExtract the following from the input files:\n\t\t1. Residue positions of all residues for each chain.\n\t\t2. Ca or representative atom coordinates.\n\t\t3. Ca or representative atom pLDDT.\n\t\t4. Tokenized chain IDs.\n\t\t5. Tokenized residue IDs.\n\t\t6. Chain lengths.\n\t\t7. PAE matrix.\n\t\t8. Average PAE matrix.\n\t\t9. Min PAE for each residue.\n\t\"\"\"\n\n\tdata = self.dataparser.get_data_dict()\n\tself.pae = self.dataparser.get_pae(data=data)\n\tself.avg_pae = self.dataparser.get_avg_pae(pae=self.pae)\n\tself.contact_probs_mat = self.dataparser.get_contact_probs_mat(data=data)\n\n\tif self.contact_probs_mat is not None:\n\t\tself.avg_contact_probs_mat = self.dataparser.get_avg_contact_probs_mat(\n\t\t\tcontact_probs_mat=self.contact_probs_mat\n\t\t)\n\n\tself.token_chain_ids = self.dataparser.get_token_chain_ids(data=data)\n\tself.token_res_ids = self.dataparser.get_token_res_ids(data=data)\n\n\tif self.token_chain_ids is None or self.token_res_ids is None:\n\t\tself.token_chain_ids, self.token_res_ids = self.structureparser.get_token_chain_res_ids()\n\n\t# Ca-coords of all residues for each chain.\n\tself.coords_list = self.structureparser.get_ca_coordinates()\n\t# Ca-plddt of all residues for each chain.\n\tself.plddt_list = self.structureparser.get_ca_plddt()\n\n\tself.pae = self.update_pae(\n\t\tpae=self.pae,\n\t\ttoken_res_ids=self.token_res_ids,\n\t\ttoken_chain_ids=self.token_chain_ids,\n\t\taverage_atom_pae=self.average_atom_pae,\n\t)\n\tself.avg_pae = self.update_pae(\n\t\tpae=self.avg_pae,\n\t\ttoken_res_ids=self.token_res_ids,\n\t\ttoken_chain_ids=self.token_chain_ids,\n\t\taverage_atom_pae=self.average_atom_pae,\n\t)\n\n\tif self.contact_probs_mat is not None:\n\n\t\tself.contact_probs_mat = self.update_contact_probs(\n\t\t\tcontact_probs_mat=self.contact_probs_mat,\n\t\t\ttoken_chain_ids=self.token_chain_ids,\n\t\t\ttoken_res_ids=self.token_res_ids,\n\t\t\taverage_atom_pae=self.average_atom_pae,\n\t\t)\n\t\tself.avg_contact_probs_mat = self.update_contact_probs(\n\t\t\tcontact_probs_mat=self.avg_contact_probs_mat,\n\t\t\ttoken_chain_ids=self.token_chain_ids,\n\t\t\ttoken_res_ids=self.token_res_ids,\n\t\t\taverage_atom_pae=self.average_atom_pae,\n\t\t)\n\n\tself.token_chain_ids, self.token_res_ids = self.update_token_ids(\n\t\ttoken_chain_ids=self.token_chain_ids,\n\t\ttoken_res_ids=self.token_res_ids,\n\t\taverage_atom_pae=self.average_atom_pae,\n\t)\n\n\tself.lengths_dict = self.get_chain_lengths(\n\t\ttoken_chain_ids=self.token_chain_ids,\n\t)\n\tself.sanity_check()\n\tself.idx_to_num, self.num_to_idx = self.renumber.residue_map(\n\t\ttoken_chain_ids=self.token_chain_ids,\n\t\ttoken_res_ids=self.token_res_ids,\n\t)\n```","x":-1364,"y":-1378,"width":971,"height":1485,"color":"3"},
		{"id":"6939e925e7239b44","type":"text","text":"```py\ndef sanity_check(self):\n\t\"\"\"\n\tPerform sanity checks on the input data. \\n\n\tIf structure file path is not provided, the input data file should be in AF3 format.\n\t\"\"\"\n\n\terror_statement = \"Input data file needs to be in AF3 format if structure path is not provided.\"\n\n\tif not self.lengths_dict:\n\t\traise Exception(f\"No chain lengths found. {error_statement}\")\n```","collapsed":true,"alias":"sanity_check","x":-1364,"y":-1218,"width":975,"height":335,"color":"3"},
		{"alias":"_Initialize._Initialize","collapsed":true,"id":"e2c2bd72e53bb5a8","type":"text","text":"```python\nclass _Initialize(AfParser)\n```\n\n```mermaid\nclassDiagram\n    class _Initialize {\n        - __init__(self, data_file_path, struct_file_path, af_offset, **kwargs) None\n        + get_attributes(self)\n        + sanity_check(self)\n    }\n```","x":-2288,"y":-1294,"width":585,"height":280,"color":"5"},
		{"alias":"get_parser","collapsed":true,"id":"696bb2ec4b794453","type":"text","text":"```py\ndef get_parser(self):\n\t\"\"\"\n\tGet the required parser (PDB/CIF) for the input file.\n\n\tArgs:\n\t\tstruct_file_path (str): path to the structure file.\n\n\tReturns:\n\t\tparser (Bio.PDB.PDBParser | Bio.PDB.MMCIFParser): parser object.\n\t\"\"\"\n\n\text = os.path.splitext(self.struct_file_path)[1]\n\n\tif \"pdb\" in ext:\n\t\tparser = PDBParser()\n\n\t\tif self.preserve_header_footer:\n\t\t\traise Exception(\"Header can only be preserved for CIF files.\")\n\n\telif \"cif\" in ext:\n\n\t\tif self.which_parser == \"biopython\":\n\t\t\tparser = MMCIFParser()\n\n\t\telif self.which_parser == \"pdbe\":\n\t\t\tparser = CifFileReader(input='data')\n\n\telse:\n\t\traise Exception(\"Incorrect file format.. Suported .pdb/.cif only.\")\n\n\treturn parser\n```","x":-501,"y":-2956,"width":807,"height":780,"color":"3"},
		{"alias":"get_structure","collapsed":true,"id":"72d276fc1f52cd23","type":"text","text":"```py\ndef get_structure(\n\tself,\n\tparser: Bio.PDB.PDBParser | Bio.PDB.MMCIFParser | pdbecif.mmcif_io.CifFileReader,\n):\n\t\"\"\"\n\tReturn the Biopython Structure object for the input file.\n\n\tArgs:\n\t\tparser (Bio.PDB.PDBParser | Bio.PDB.MMCIFParser): parser object.\n\n\tReturns:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object.\n\t\"\"\"\n\n\tbasename = os.path.basename(self.struct_file_path)\n\n\tif isinstance(parser, Bio.PDB.PDBParser) or isinstance(parser, Bio.PDB.MMCIFParser):\n\n\t\tstructure = parser.get_structure(\n\t\t\tbasename,\n\t\t\tself.struct_file_path\n\t\t)\n\n\t\tif self.preserve_header_footer:\n\t\t\tstructure = self.add_header_footer(\n\t\t\t\tstructure=structure,\n\t\t\t\tstruct_file_path=self.struct_file_path\n\t\t\t)\n\n\t\t# decorate residues with entity types\n\t\tfor model in structure:\n\t\t\tfor chain in model:\n\t\t\t\tfor residue in chain:\n\t\t\t\t\tself.decorate_residue(residue=residue)\n\n\telif isinstance(parser, CifFileReader):\n\t\traise NotImplementedError(\n\t\t\t\"CifFileReader is not implemented yet. \"\n\t\t\t\"Please use PDBParser or MMCIFParser.\"\n\t\t)\n\n\treturn structure\n```","x":-501,"y":-2896,"width":877,"height":969,"color":"3"},
		{"alias":"add_header_footer","collapsed":true,"id":"c102197206cb9ffd","type":"text","text":"```py\ndef add_header_footer(\n\tself,\n\tstructure: Bio.PDB.Structure.Structure,\n\tstruct_file_path: str,\n):\n\t\"\"\" Add the header and footer information to the structure object.\n\n\tArgs:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object.\n\t\tstruct_file_path (str): path to the structure file.\n\n\tReturns:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object with 'header_footer'.\n\t\"\"\"\n\n\twith open(struct_file_path, \"r\") as f:\n\t\tlines = f.readlines()\n\n\theader_info = []\n\theader_section = \"\"\n\n\tfor line in lines:\n\t\theader_section += line\n\n\t\tif line.startswith(\"#\"):\n\t\t\theader_info.append(header_section)\n\t\t\theader_section = \"\"\n\n\t\tif line.startswith(\"_atom_site\"):\n\t\t\tbreak\n\n\tfooter_info = []\n\tfooter_section = \"\"\n\n\tfor line in lines[::-1]:\n\t\tfooter_section = line + footer_section\n\n\t\tif line.startswith(\"#\"):\n\t\t\tfooter_info.append(footer_section)\n\t\t\tfooter_section = \"\"\n\n\t\tif line.startswith(\"ATOM\") or line.startswith(\"HETATM\"):\n\t\t\tbreak\n\n\tstructure.header_footer = {\n\t\t\"header\": header_info,\n\t\t\"footer\": footer_info,\n\t}\n\n\treturn structure\n```","x":-501,"y":-2836,"width":917,"height":1140,"color":"3"},
		{"alias":"get_residues","collapsed":true,"id":"ff30e281989fbee9","type":"text","text":"```py\ndef get_residues(self):\n\t\"\"\"\n\tGet all residues in the structure.\n\n\tArgs:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object.\n\n\tYields:\n\t\tresidue (Bio.PDB.Residue.Residue): Biopython residue object. \\n\n\t\tchain_id (str): chain ID.\n\t\"\"\"\n\n\tfor model in self.structure:\n\t\tfor chain in model:\n\t\t\tchain_id = chain.id[0]\n\t\t\tfor residue in chain:\n\n\t\t\t\tyield residue, chain_id\n```","x":-501,"y":-2776,"width":744,"height":501,"color":"3"},
		{"alias":"decorate_residues","collapsed":true,"id":"41539ad4a45137dd","type":"text","text":"```py\ndef decorate_residue(self, residue: Bio.PDB.Residue.Residue):\n\n\tsymbol = residue.get_resname()\n\n\tif symbol in PROTEIN_ENTITIES:\n\t\tresidue.xtra[\"entityType\"] = \"proteinChain\"\n\n\telif symbol in DNA_ENTITIES:\n\t\tresidue.xtra[\"entityType\"] = \"dnaSequence\"\n\n\telif symbol in RNA_ENTITIES:\n\t\tresidue.xtra[\"entityType\"] = \"rnaSequence\"\n\n\telif symbol in ALLOWED_LIGANDS:\n\t\tresidue.xtra[\"entitiyType\"] = \"ligand\"\n\n\telif symbol in ION:\n\t\tresidue.xtra[\"entityType\"] = \"ion\"\n\n\telse:\n\t\twarnings.warn(\n\t\t\tf\"\"\"\n\t\t\tThe residue {symbol} does not belong to any known entity types.\n\t\t\tSetting 'entityType' to None.\n\t\t\t\"\"\"\n\t\t)\n\t\tresidue.xtra[\"entityType\"] = None\n```","x":-501,"y":-2716,"width":748,"height":665,"color":"3"},
		{"alias":"Parser.StructureParser","collapsed":true,"id":"02052820abfcae00","type":"text","text":"```py\nclass StructureParser\n```\n\n```mermaid\nclassDiagram\n    class StructureParser {\n        - __init__(self, struct_file_path, **kwargs) None\n        + get_parser(self)\n        + get_structure(self, parser)\n        + add_header_footer(self, structure, struct_file_path)\n        + get_residues(self)\n        + decorate_residue(self, residue)\n        + extract_perresidue_quantity(self, residue, quantity)\n        + get_token_chain_res_ids(self)\n        + get_ca_coordinates(self)\n        + get_ca_plddt(self)\n    }\n```","x":-1341,"y":-2656,"width":580,"height":500,"color":"5"},
		{"alias":"extract_perresidue_quantity","collapsed":true,"id":"8034d0e8bac48270","type":"text","text":"```py\ndef extract_perresidue_quantity(\n\tself,\n\tresidue: Bio.PDB.Residue.Residue,\n\tquantity: str\n):\n\t\"\"\"\n\tGiven the Biopython residue object, return the specified quantity: \\n\n\t\t1. residue or nucleotide or ion position \\n\n\t\t2. Cb-coordinate or representative atom coordinate \\n\n\t\t3. Cb-pLDDT or representative atom pLDDT\n\n\tArgs:\n\t\tresidue (Bio.PDB.Residue.Residue): Biopython residue object.\n\t\tquantity (str): quantity to extract.\n\n\tReturns:\n\t\tres_id (int): residue position. \\n\n\t\tcoords (np.array): coordinates of the representative atom. \\n\n\t\tplddt (float): pLDDT value\n\t\"\"\"\n\n\t# Using representative atoms as specified by AF3.\n\t# https://github.com/google-deepmind/alphafold3/blob/main/src/alphafold3/model/features.py#L1317\n\n\tsymbol = residue.get_resname()\n\trep_atom = residue.child_list[0].get_name()\n\n\tif residue.xtra.get(\"entityType\") == \"proteinChain\":\n\n\t\tif \"CB\" in residue.child_dict and symbol in PROTEIN_ENTITIES: # this includes modifications\n\t\t\trep_atom = \"CB\"\n\n\t\telif \"CB\" not in residue.child_dict and symbol in ONLY_CA_RESIDUES: # this includes modifications\n\t\t\trep_atom = \"CA\"\n\n\t\telse:\n\t\t\traise Exception(\n\t\t\t\tf\"\"\"\n\t\t\t\tAre you sure this is a protein chain?\n\t\t\t\tresidue {symbol} in chain {residue.parent.id}\n\t\t\t\tdoes not have a Cb-atom or a Ca-atom.\n\t\t\t\t\"\"\"\n\t\t\t)\n\n\telif residue.xtra.get(\"entityType\") in [\"dnaSequence\", \"rnaSequence\"]:\n\n\t\tif symbol in PURINES: # this includes modifications\n\t\t\trep_atom = \"C4\"\n\n\t\telif symbol in PYRIMIDINES: # this includes modifications\n\t\t\trep_atom = \"C2\"\n\n\telif residue.xtra.get(\"entityType\") == \"ion\" and symbol in ION:\n\t\trep_atom = symbol\n\n\telif residue.xtra.get(\"entityType\") == \"ligand\":\n\t\trep_atom = residue.child_list[0].get_name()\n\t\twarnings.warn(\n\t\t\tf\"\"\"\n\t\t\tCan not determine representative atom for ligand {symbol}\n\t\t\tin chain {residue.parent.get_id()}\n\t\t\tSetting representative atom to {rep_atom}.\n\t\t\t\"\"\"\n\t\t)\n\n\telse:\n\t\trep_atom = residue.child_list[0].get_name()\n\t\twarnings.warn(\n\t\t\tf\"\"\"\n\t\t\tUnknown entity type for residue {symbol} in chain {residue.parent.id}.\n\t\t\tIt could be a glycan modification.\n\t\t\tSetting representative atom to {rep_atom}.\n\t\t\t\"\"\"\n\t\t)\n\n\tif quantity == \"res_pos\":\n\t\treturn residue.id[1]\n\n\telif quantity == \"coords\":\n\t\tcoords = residue[rep_atom].coord\n\t\treturn coords\n\n\telif quantity == \"plddt\":\n\t\tplddt = residue[rep_atom].bfactor\n\t\treturn plddt\n\n\telse:\n\t\traise Exception(\n\t\t\tf\"Specified quantity: {quantity} does not exist for {symbol}\"\n\t\t)\n```","x":-501,"y":-2656,"width":1047,"height":2003,"color":"3"},
		{"alias":"get_token_chain_res_ids","collapsed":true,"id":"af99bf2d1f265fdf","type":"text","text":"```py\ndef get_token_chain_res_ids(self):\n\t\"\"\" Get the tokenized chain IDs and residue IDs for all residues in the structure.\n\n\tReturns:\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\t\ttoken_res_ids (list): tokenized residue IDs.\n\t\"\"\"\n\n\ttoken_chain_ids = []\n\ttoken_res_ids = []\n\n\tfor residue, chain_id in self.get_residues():\n\t\tres_id = self.extract_perresidue_quantity(\n\t\t\tresidue=residue,\n\t\t\tquantity=\"res_pos\"\n\t\t)\n\n\t\ttoken_chain_ids.append(chain_id)\n\t\ttoken_res_ids.append(res_id)\n\n\treturn token_chain_ids, token_res_ids\n```","x":-501,"y":-2596,"width":818,"height":556,"color":"3"},
		{"alias":"get_ca_coordinates","collapsed":true,"id":"5dfbc8222ba08755","type":"text","text":"```py\ndef get_ca_coordinates(self):\n\t\"\"\" Get the coordinates of representative atoms for all residues in the structure.\n\n\tReturns:\n\t\tcoords_list (list): list containing the coordinates for each residue index.\n\t\"\"\"\n\n\tcoords_list = []\n\n\tfor residue, _chain_id in self.get_residues():\n\n\t\tcoords = self.extract_perresidue_quantity(\n\t\t\tresidue=residue,\n\t\t\tquantity=\"coords\"\n\t\t)\n\n\t\tcoords_list.append(coords)\n\n\treturn coords_list\n```","x":-501,"y":-2536,"width":828,"height":474,"color":"3"},
		{"collapsed":true,"id":"d2c4c77458467049","type":"text","text":"```py\ndef get_data_dict(self) -> Dict:\n\t\"\"\"\n\tParse the AF2/3 data file. \\n\n\tAF2 data file is saved as a .pkl file \\n\n\twhereas for AF3 it's stored as .json.\n\n\tArgs:\n\t\tdata_file_path (str): path to the data file.\n\n\tReturns:\n\t\tdata (Dict): data dict from the data file.\n\t\"\"\"\n\n\text = os.path.splitext(self.data_file_path)[1]\n\n\t# AF2 data file\n\tif \"pkl\" in ext:\n\t\twith open(self.data_file_path, \"rb\") as f:\n\t\t\tdata = pkl.load(f)\n\n\t# AF3 data file\n\telif \"json\" in ext:\n\t\twith open(self.data_file_path, \"r\") as f:\n\t\t\tdata = json.load(f)\n\n\t\tif isinstance(data, list):\n\t\t\tdata = data[0]\n\n\telse:\n\t\traise Exception(\"Incorrect file format.. Suported .pkl/.json only.\")\n\n\treturn data\n```","alias":"get_data_dict","x":-501,"y":-2039,"width":749,"height":783,"color":"3"},
		{"alias":"get_token_chain_ids","collapsed":true,"id":"89253dba6a6ed415","type":"text","text":"```py\ndef get_token_chain_ids(self, data: Dict) -> list:\n\t\"\"\" Get the tokenized chain IDs from the data dict. \\n\n\tThis is specific to AF3: \"token_chain_ids\" key. \\n\n\tIf data is AF2, None is returned. \\n\n\tHowever, similar information can be obtained from the structure file. \\n\n\tsee :py:meth:`Parser.StructureParser.get_token_chain_res_ids`.\n\n\tArgs:\n\t\tdata (Dict): data dict from the data file.\n\n\tReturns:\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\t\"\"\"\n\n\tif \"token_chain_ids\" in data:\n\t\ttoken_chain_ids = data[\"token_chain_ids\"]\n\n\telse:\n\t\twarnings.warn(\n\t\t\t\"\"\"\n\t\t\tChain IDs not found, data file might be AF2.\n\t\t\tStructure file is required for AF2.\n\t\t\t\"\"\"\n\t\t)\n\t\ttoken_chain_ids = None\n\n\treturn token_chain_ids\n```","x":-501,"y":-1996,"width":747,"height":683,"color":"3"},
		{"collapsed":true,"id":"2f1b179777efd10c","type":"text","text":"```py\n    def get_token_res_ids(self, data: Dict) -> list:\n        \"\"\" Get the tokenized residue IDs from the data dict. \\n\n        This is specific to AF3: \"token_res_ids\" key. \\n\n        If data is AF2, None is returned. \\n\n        However, similar information can be obtained from the structure file. \\n\n        see :py:meth:`Parser.AfParser.StructureParser.get_token_chain_res_ids`.\n\n        Args:\n            data (Dict): data dict from the data file.\n\n        Returns:\n            token_res_ids (list): tokenized residue IDs.\n        \"\"\"\n\n        if \"token_res_ids\" in data:\n            token_res_ids = data[\"token_res_ids\"]\n\n        else:\n            warnings.warn(\n                \"\"\"\n                Residue IDs not found, data file might be AF2.\n                Structure file is required for AF2.\n                \"\"\"\n            )\n            token_res_ids = None\n\n        return token_res_ids\n```","alias":"get_token_res_ids","x":-501,"y":-1956,"width":748,"height":672,"color":"3"},
		{"collapsed":true,"id":"c9499d90e7fdf845","type":"text","text":"```py\ndef get_pae(self, data: Dict):\n\t\"\"\"\n\tReturn the PAE matrix from the data dict. \\n\n\n\tArgs:\n\t\tdata (Dict): data dict from the data file.\n\n\tReturns:\n\t\tpae (np.array): PAE matrix.\n\t\"\"\"\n\n\t# For AF2.\n\tif \"predicted_aligned_error\" in data:\n\t\tpae = np.array(data[\"predicted_aligned_error\"])\n\n\t# For AF3.\n\telif \"pae\" in data:\n\t\tpae = np.array(data[\"pae\"])\n\n\telse:\n\t\traise Exception(\"PAE matrix not found...\")\n\n\treturn pae\n```","alias":"get_pae","x":-501,"y":-1916,"width":564,"height":580,"color":"3"},
		{"alias":"get_avg_pae","collapsed":true,"id":"dff8949bbb70453a","type":"text","text":"```py\ndef get_avg_pae(self, pae: np.ndarray):\n\t\"\"\"\n\tReturn the average PAE matrix. \\n\n\n\tArgs:\n\t\tpae (np.array): PAE matrix.\n\n\tReturns:\n\t\tavg_pae (np.array): average PAE matrix.\n\t\"\"\"\n\n\tavg_pae = (pae + pae.T) / 2\n\n\treturn avg_pae\n```","x":-501,"y":-1876,"width":510,"height":407,"color":"3"},
		{"alias":"get_contact_probs_mat","collapsed":true,"id":"fa3fbcd999faba43","type":"text","text":"```py\ndef get_contact_probs_mat(self, data: Dict):\n\t\"\"\" Get the contact probabilities from the data dict. \\n\n\n\tArgs:\n\t\tdata (Dict): data dict from the data file.\n\n\tReturns:\n\t\tcontact_probs_mat (np.array): contact probabilities matrix.\n\t\"\"\"\n\n\tif \"contact_probs\" in data:\n\t\tcontact_probs_mat = np.array(data[\"contact_probs\"])\n\n\telse:\n\t\twarnings.warn(\n\t\t\t\"Contact probabilities not found, data file might not be AF3.\"\n\t\t)\n\t\tcontact_probs_mat = None\n\n\treturn contact_probs_mat\n```","x":-501,"y":-1836,"width":728,"height":514,"color":"3"},
		{"alias":"get_ca_plddt","collapsed":true,"id":"b469e5b1d3b488bd","type":"text","text":"```py\ndef get_ca_plddt(self):\n\t\"\"\" Get the pLDDT values for all residues in the structure.\n\n\tReturns:\n\t\tplddt_list (list): list containing the pLDDT values for residue index.\n\t\"\"\"\n\n\tplddt_list = []\n\n\tfor residue, _chain_id in self.get_residues():\n\n\t\tplddt = self.extract_perresidue_quantity(\n\t\t\tresidue=residue,\n\t\t\tquantity=\"plddt\"\n\t\t)\n\n\t\tplddt_list.append(plddt)\n\n\treturn plddt_list\n```","x":-501,"y":-2476,"width":785,"height":496,"color":"3"},
		{"alias":"create_mask","collapsed":true,"id":"d67b3c7391abb2d1","type":"text","text":"```py\ndef create_mask(\n\t\tself,\n\t\tlengths_dict: Dict,\n\t\thide_interactions: str = \"intrachain\"\n\t) -> np.ndarray:\n\t\"\"\"\n\tCreate a binary 2D mask for selecting only interchain or intrachain interactions. \\n\n\tThe mask is created by setting the values of the intrachain or interchain interactions to -100. \\n\n\tif hide_interactions is set to \"intrachain\", the intrachain interactions are set to -100. \\n\n\tif hide_interactions is set to \"interchain\", the interchain interactions are set to -100.\n\n\tArgs:\n\t\tlengths_dict (Dict): dict containing the chain lengths. {chain_id: length}\n\t\thide_interactions (str): hide intrachain or interchain interactions. (default: \"intrachain\")\n\n\tReturns:\n\t\tmask_ (np.ndarray): binary 2D mask for selecting only interchain interactions.\n\t\"\"\"\n\n\tassert hide_interactions in [\n\t\t\"intrachain\",\n\t\t\"interchain\",\n\t]; \"hide_interactions should be either 'intrachain' or 'interchain'.\"\n\n\tsys_len = lengths_dict[\"total\"]\n\tmask_ = np.ones((sys_len, sys_len))\n\n\tprev = 0\n\tfor chain in lengths_dict:\n\t\tif chain == \"total\":\n\t\t\tcontinue\n\t\tl = lengths_dict[chain]\n\t\tcurr = prev + l\n\t\tmask_[prev:curr:, prev:curr] = -100\n\t\tprev += l\n\n\tif hide_interactions == \"intrachain\":\n\t\treturn mask_\n\n\telif hide_interactions == \"interchain\":\n\t\tnew_mask_ = np.ones((sys_len, sys_len))\n\t\tnew_mask_[mask_ == 1] = -100\n\t\treturn new_mask_\n\n\telse:\n\t\traise Exception(\n\t\t\t\"hide_interactions should be either 'intrachain' or 'interchain'.\"\n\t\t)\n```","x":-501,"y":-2396,"width":962,"height":1122,"color":"3"},
		{"alias":"get_min_pae","collapsed":true,"id":"7118114a0767f034","type":"text","text":"```py\ndef get_min_pae(\n\tself,\n\tavg_pae: np.ndarray,\n\tlengths_dict: Dict,\n\thide_interactions: str = \"intrachain\",\n\treturn_dict: bool = False,\n) -> np.ndarray | Dict:\n\n\t\"\"\"\n\tGiven the averaged PAE matrix, obtain min PAE values for all residues. \\n\n\tEssentially return a vector containing row-wise min PAE values.\\n\n\tmin_pae indicates the minimum error in the interaction with some residue.\n\n\tIf hide_interactions is set to \"intrachain\", only the interchain interactions are considered. \\n\n\tIf hide_interactions is set to \"interchain\", only the intrachain interactions are considered.\n\n\treturn_dict is set to True, a dictionary containing the min PAE values for each chain is returned. \\n\n\n\tArgs:\n\t\tavg_pae (np.ndarray): average PAE matrix.\n\t\tlengths_dict (Dict): dict containing the chain lengths. {chain_id: length}\n\t\thide_interactions (str): hide intrachain or interchain interactions.\n\t\treturn_dict (bool): return min_pae_dict or min_pae.\n\n\tReturns:\n\t\tmin_pae_dict (Dict): dict containing the min PAE values for each chain.\n\t\tmin_pae (np.ndarray): min PAE values for all residues\n\t\"\"\"\n\n\tinterchain_mask = self.create_mask(\n\t\tlengths_dict=lengths_dict,\n\t\thide_interactions=hide_interactions,\n\t)\n\n\tavg_pae[avg_pae == 0] = 1e-10 # to avoid zeros\n\tavg_pae = avg_pae * interchain_mask\n\n\tmin_pae = np.min(np.abs(avg_pae), axis=1)\n\n\tmin_pae_dict = {}\n\tstart = 0\n\n\tfor chain_id in lengths_dict:\n\t\tif chain_id != \"total\":\n\n\t\t\tend = start + lengths_dict[chain_id]\n\t\t\tmin_pae_dict[chain_id] = min_pae[start:end]\n\t\t\tstart = end\n\n\tif return_dict:\n\t\treturn min_pae_dict\n\n\telse:\n\t\treturn min_pae\n```","x":-501,"y":-2336,"width":991,"height":1274,"color":"3"},
		{"alias":"get_chain_lengths","collapsed":true,"id":"cfdc8495c0f80a06","type":"text","text":"```py\ndef get_chain_lengths(self, token_chain_ids: list) -> Dict:\n\t\"\"\" Get the chain lengths. \\n\n\tlengths_dict is a dictionary containing the chain lengths. \\n\n\t{chain_id: length} \\n\n\t\"total\" is the total length of the system. \\n\n\tFor example, if the system has 2 chains A and B, \\n\n\tlengths_dict = {\"A\": 100, \"B\": 50, \"total\": 150} \\n\n\n\tArgs:\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\n\tReturns:\n\t\tlengths_dict (Dict): dict containing the chain lengths.\n\t\"\"\"\n\n\tlengths_dict = {}\n\tlengths_dict[\"total\"] = 0\n\n\tfor chain_id in token_chain_ids:\n\t\tif chain_id not in lengths_dict:\n\t\t\tlengths_dict[chain_id] = 1\n\t\telse:\n\t\t\tlengths_dict[chain_id] += 1\n\t\tlengths_dict[\"total\"] += 1\n\n\treturn lengths_dict\n```","x":-501,"y":-2284,"width":646,"height":648,"color":"3"},
		{"collapsed":true,"id":"ef316634bc0c8b8c","type":"text","text":"```py\ndef update_token_ids(\n\tself,\n\ttoken_chain_ids: list,\n\ttoken_res_ids: list,\n\t**kwargs,\n) -> tuple:\n\t\"\"\" Update the token IDs based on the keyword. \\n\n\tIf average_atom_pae is set to True, the repeated residue IDs are removed. \\n\n\n\tArgs:\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\t\ttoken_res_ids (list): tokenized residue IDs.\n\n\tReturns:\n\t\ttoken_chain_ids (list): updated tokenized chain IDs.\n\t\ttoken_res_ids (list): updated tokenized residue IDs.\n\t\"\"\"\n\n\tif kwargs.get(\"average_atom_pae\", False):\n\t\ttoken_ids = list(zip(token_chain_ids, token_res_ids))\n\n\t\tindices_to_remove = get_duplicate_indices(token_ids)\n\n\t\ttoken_chain_ids = [\n\t\t\tchain_id\n\t\t\tfor _idx, chain_id\n\t\t\tin enumerate(token_chain_ids)\n\t\t\tif _idx not in indices_to_remove\n\t\t]\n\n\t\ttoken_res_ids = [\n\t\t\tres_id\n\t\t\tfor _idx, res_id\n\t\t\tin enumerate(token_res_ids)\n\t\t\tif _idx not in indices_to_remove\n\t\t]\n\n\treturn token_chain_ids, token_res_ids\n```","alias":"update_token_ids","x":-501,"y":-2236,"width":790,"height":928,"color":"3"},
		{"alias":"update_pae","collapsed":true,"id":"dd644e1e90c8a2d3","type":"text","text":"```py\ndef update_pae(\n\tself,\n\tpae: np.ndarray,\n\ttoken_res_ids: list,\n\ttoken_chain_ids: list,\n\t**kwargs,\n):\n\t\"\"\" Update the PAE matrix based on the keyword. \\n\n\tIf average_atom_pae is set to True, the repeated residue IDs are removed. \\n\n\tPAE values for the repeated residue IDs are replaced with the mean of the PAE values. \\n\n\n\tArgs:\n\t\tpae (np.ndarray): PAE matrix.\n\t\ttoken_res_ids (list): tokenized residue IDs.\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\n\tReturns:\n\t\tpae (np.ndarray): updated PAE matrix.\n\t\"\"\"\n\n\tif kwargs.get(\"average_atom_pae\", False):\n\n\t\ttoken_ids = list(zip(token_chain_ids, token_res_ids))\n\n\t\tmod_res_indices = get_duplicate_indices(\n\t\t\tmy_li=token_ids,\n\t\t\treturn_type=\"dict\",\n\t\t)\n\n\t\tpaes_to_replace = []\n\t\tindices_to_remove = get_duplicate_indices(token_ids)\n\n\t\t# the first index for each repeated residue will be replaced with the mean\n\t\tfor res, indexes in mod_res_indices.items():\n\t\t\tstart, end = indexes\n\t\t\tend += 1\n\t\t\tcenter_val = np.mean(pae[start:end, start:end])\n\t\t\tcol_val = np.mean(pae[start:end, :], axis=0)\n\t\t\trow_val = np.mean(pae[:, start:end], axis=1)\n\n\t\t\tfor start_, end_ in mod_res_indices.values():\n\t\t\t\tend_ += 1\n\n\t\t\t\trow_val[start_:end_] = np.mean(row_val[start_:end_])\n\t\t\t\tcol_val[start_:end_] = np.mean(col_val[start_:end_])\n\n\t\t\tpaes_to_replace.append(\n\t\t\t\t{\n\t\t\t\t\t\"pos\": start,\n\t\t\t\t\t\"center_mean\": center_val,\n\t\t\t\t\t\"row_mean\": row_val,\n\t\t\t\t\t\"col_mean\": col_val,\n\t\t\t\t}\n\t\t\t)\n\n\t\tfor to_replace in paes_to_replace:\n\t\t\tstart = to_replace[\"pos\"]\n\t\t\tpae[:, start] = to_replace[\"row_mean\"]\n\t\t\tpae[start, :] = to_replace[\"col_mean\"]\n\t\t\tpae[start, start] = to_replace[\"center_mean\"]\n\n\t\tmask = np.ones(pae.shape[0], dtype=bool)\n\t\tmask[indices_to_remove] = False\n\t\tpae = pae[mask][:, mask]\n\n\treturn pae\n```","x":-501,"y":-2176,"width":945,"height":1423,"color":"3"},
		{"alias":"update_contact_probs","collapsed":true,"id":"2f73dbf7e691bb21","type":"text","text":"```py\ndef update_contact_probs(\n\tself,\n\tcontact_probs_mat: np.ndarray,\n\ttoken_chain_ids: list,\n\ttoken_res_ids: list,\n\t**kwargs,\n):\n\t\"\"\" Update the contact probabilities matrix based on the keyword. \\n\n\tIf average_atom_pae is set to True, the repeated residue IDs are removed. \\n\n\n\tArgs:\n\t\tcontact_probs_mat (np.ndarray): contact probabilities matrix.\n\t\tavg_contact_probs_mat (np.ndarray): average contact probabilities matrix.\n\t\ttoken_chain_ids (list): tokenized chain IDs.\n\t\ttoken_res_ids (list): tokenized residue IDs.\n\n\tReturns:\n\t\tcontact_probs_mat (np.ndarray): updated contact probabilities matrix.\n\t\tavg_contact_probs_mat (np.ndarray): updated average contact probabilities matrix.\n\t\"\"\"\n\n\tif kwargs.get(\"average_atom_pae\", False):\n\n\t\ttoken_ids = list(zip(token_chain_ids, token_res_ids))\n\t\tindices_to_remove = get_duplicate_indices(token_ids)\n\n\t\tmask = np.ones(contact_probs_mat.shape[0], dtype=bool)\n\t\tmask[indices_to_remove] = False\n\n\t\tcontact_probs_mat = contact_probs_mat[mask][:, mask]\n\n\treturn contact_probs_mat\n```","x":-501,"y":-2116,"width":862,"height":770,"color":"3"},
		{"alias":"Parser.AfParser","id":"0fba078d74296741","type":"text","text":"```python\nclass AfParser\n```\n\n```mermaid\nclassDiagram\n    class AfParser {\n        - __init__(self, data_file_path, struct_file_path, af_offset, **kwargs) None\n        + create_mask(self, lengths_dict, hide_interactions) np.ndarray\n        + get_min_pae(self, avg_pae, lengths_dict, hide_interactions, return_dict) np.ndarray | Dict\n        + get_chain_lengths(self, token_chain_ids) Dict\n        + update_token_ids(self, token_chain_ids, token_res_ids, **kwargs) tuple\n        + update_pae(self, pae, token_res_ids, token_chain_ids, **kwargs)\n        + update_contact_probs(self, contact_probs_mat, token_chain_ids, token_res_ids, **kwargs)\n    }\n```\n","collapsed":true,"x":-1421,"y":-2276,"width":740,"height":434,"color":"5"},
		{"alias":"get_avg_contact_probs_mat","collapsed":true,"id":"9c59f535d25a6880","type":"text","text":"```py\ndef get_avg_contact_probs_mat(self, contact_probs_mat: np.ndarray):\n\t\"\"\"\n\tReturn the average contact probabilities matrix. \\n\n\n\tArgs:\n\t\tcontact_probs_mat (np.array): contact probabilities matrix.\n\n\tReturns:\n\t\tavg_contact_probs_mat (np.array): average contact probabilities matrix.\n\t\"\"\"\n\n\tavg_contact_probs_mat = (contact_probs_mat + contact_probs_mat.T) / 2\n\n\treturn avg_contact_probs_mat\n```","x":-501,"y":-1796,"width":767,"height":418,"color":"3"},
		{"alias":"accept_residues","collapsed":true,"id":"7cc5c3b46b7646e5","type":"text","text":"```py\ndef accept_residue(\n\tself,\n\tresidue: Bio.PDB.Residue.Residue\n) -> bool:\n\t\"\"\"Accept the residue if it's in the confident_residues dict.\n\n\tArgs:\n\t\tresidue (Bio.PDB.Residue.Residue): Biopython residue object.\n\n\tReturns:\n\t\tbool: True if the residue is in the confident_residues dict.\n\t\"\"\"\n\n\tchain = residue.parent.id\n\n\treturn residue.id[1] in self.confident_residues[chain]\n```","x":-501,"y":-1696,"width":673,"height":431,"color":"3"},
		{"collapsed":true,"id":"4ec6c15d90feabff","type":"text","text":"```py\nclass DataParser\n```\n\n```mermaid\nclassDiagram\n    class DataParser {\n        - __init__(self, data_file_path) None\n        + get_data_dict(self) Dict\n        + get_token_chain_ids(self, data) list\n        + get_token_res_ids(self, data) list\n        + get_pae(self, data)\n        + get_avg_pae(self, pae)\n        + get_contact_probs_mat(self, data)\n        + get_avg_contact_probs_mat(self, contact_probs_mat)\n    }\n```","alias":"Parser.DataParser","x":-1367,"y":-1896,"width":632,"height":419,"color":"5"},
		{"alias":"Parser.ResidueSelect","collapsed":true,"id":"f06f13c367c07676","type":"text","text":"```py\nclass ResidueSelect(Select)\n```\n\n```mermaid\nclassDiagram\n    class ResidueSelect {\n        - __init__(self, confident_residues) None\n        + accept_residue(self, residue) bool\n    }\n```","x":-1271,"y":-1696,"width":440,"height":300,"color":"5"},
		{"alias":"renumber_structure","collapsed":true,"id":"97147b0f899e7074","type":"text","text":"```py\ndef renumber_structure(\n\tself,\n\tstructure: Bio.PDB.Structure.Structure,\n):\n\t\"\"\"Renumber the residues in the structure based on the offset. \\n\n\te.g. af_offset = {'A': [30, 100], 'B': [10, 50]}\n\n\tArgs:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object.\n\n\tReturns:\n\t\tstructure (Bio.PDB.Structure.Structure): Biopython Structure object with renumbered residues.\n\t\"\"\"\n\n\tfor model in structure:\n\t\tfor chain in model:\n\t\t\tchain_id = chain.id\n\t\t\tfor residue in chain:\n\t\t\t\th, num, ins = residue.id\n\n\t\t\t\tnum = self.renumber_chain_res_num(\n\t\t\t\t\tchain_res_num=num,\n\t\t\t\t\tchain_id=chain_id,\n\t\t\t\t)\n\n\t\t\t\tresidue.id = (h, num, ins)\n\n\treturn structure\n```","x":-3381,"y":-2357,"width":934,"height":701,"color":"3"},
		{"alias":"renumber_chain_res_num","collapsed":true,"id":"6c09a2b027488544","type":"text","text":"```py\ndef renumber_chain_res_num(\n\tself,\n\tchain_res_num: int,\n\tchain_id: str,\n):\n\t\"\"\"\n\tRenumber the residue number based on the offset.\n\n\tArgs:\n\t\tchain_res_num (int): residue number\n\t\taf_offset (dict): offset dictionary\n\n\tReturns:\n\t\tchain_res_num (int): renumbered residue number\n\t\"\"\"\n\n\tif self.af_offset and chain_id in self.af_offset:\n\t\tchain_res_num += self.af_offset[chain_id][0] - 1\n\n\treturn chain_res_num\n```","x":-3070,"y":-2296,"width":623,"height":519,"color":"3"},
		{"alias":"renumber_region_of_interest","collapsed":true,"id":"90fe787799ddf310","type":"text","text":"```py\ndef renumber_region_of_interest(\n\tself,\n\tregion_of_interest: Dict,\n):\n\t\"\"\"\n\tOffset the interacting region to the AF2/3 numbering. \\n\n\tInteracting region defined by user is as per the original numbering (UniProt in case of proteins). \\n\n\tHowever, if the prediction is done on a fragment of the protein, the numbering will be different. \\n\n\tThis function offsets the interacting region to the numbering of the predicted structure. \\n\n\tBy default, the offset is assumed to be 0.\n\n\tArgs:\n\t\tregion_of_interest (Dict): dict containing the region of interest for each chain.\n\n\tReturns:\n\t\trenumbered_region_of_interest (Dict): dict containing the renumbered region of interest for each chain.\n\n\tExample:\n\t\tconsider a prediction involving proteins A (100 aa) and B (50 aa). \\n\n\t\tprediction is done on a fragment of A (30-100) and B (10-50). \\n\n\t\tso, user defines - \\n\n\t\taf_offset = {'A': [30, 100], 'B': [10, 50]} \\n\n\t\tregion_of_interest = {'A': (30, 50), 'B': (20, 40)}\n\n\t\trenumbered_region_of_interest = {'A': (1, 21), 'B': (11, 31)} \\n\n\t\ti.e. within the predicted structure, the functions in the Interaction class will look for\n\t\tinteractions in the region of: 1-21 resdiue of A and 11-31 residues of B.\n\t\"\"\"\n\n\trenumbered_region_of_interest = {}\n\n\tfor chain_id in region_of_interest:\n\n\t\tstart, end = region_of_interest[chain_id]\n\n\t\tif self.af_offset and chain_id in self.af_offset:\n\n\t\t\tstart = start - (self.af_offset[chain_id][0] - 1)\n\t\t\tend = end - (self.af_offset[chain_id][0] - 1)\n\n\t\trenumbered_region_of_interest[chain_id] = [start, end]\n\n\treturn renumbered_region_of_interest\n```","x":-3496,"y":-2236,"width":1049,"height":994,"color":"3"},
		{"alias":"residue_map","collapsed":true,"id":"b5581c496d149602","type":"text","text":"```py\ndef residue_map(\n\tself,\n\ttoken_chain_ids: list,\n\ttoken_res_ids: list\n):\n\t\"\"\"\n\tCreate a mapping of residue indices to residue numbers and vice-versa. \\n\n\tres_idx is essentially token index. \\n\n\tres_num is the residue number. \\n\n\tres_num = res_idx + 1 if af_offset is not provided. \\n\n\tres_num = res_idx + af_offset if af_offset is provided. \\n\n\taf_offset informs what is the starting residue number for each chain.\n\t\"\"\"\n\n\tidx_to_num = {}\n\tnum_to_idx = defaultdict(dict)\n\n\tfor res_idx, (chain_id, res_num) in enumerate(\n\t\tzip(token_chain_ids, token_res_ids)\n\t):\n\n\t\tres_num = self.renumber_chain_res_num(\n\t\t\tchain_res_num=res_num,\n\t\t\tchain_id=chain_id,\n\t\t)\n\n\t\tidx_to_num[res_idx] = {\n\t\t\t\"chain_id\": chain_id,\n\t\t\t\"res_num\": res_num,\n\t\t}\n\n\t\tnum_to_idx[chain_id][res_num] = res_idx\n\n\treturn idx_to_num, num_to_idx\n```","x":-3210,"y":-2176,"width":763,"height":820,"color":"3"},
		{"id":"7597227871dc4aed","type":"text","text":"```py\nclass RenumberResidues\n```\n\n```mermaid\nclassDiagram\n    class RenumberResidues {\n        - __init__(self, af_offset) None\n        + renumber_structure(self, structure)\n        + renumber_chain_res_num(self, chain_res_num, chain_id)\n        + renumber_region_of_interest(self, region_of_interest)\n        + residue_map(self, token_chain_ids, token_res_ids)\n    }\n```","alias":"Parser.RenumberResidues","collapsed":true,"x":-2281,"y":-2276,"width":533,"height":324,"color":"5"},
		{"alias":"Interaction.Interaction","collapsed":true,"id":"8d39257a9640ecf5","type":"text","text":"```py\nclass Interaction(_Initialize)\n```\n\n```mermaid\nclassDiagram\n    class Interaction {\n        - __init__(self, struct_file_path, data_file_path, af_offset, output_dir, idr_chains, **kwargs) None\n        + create_regions_of_interest(self)\n        + get_interaction_data(self, region_of_interest)\n        + apply_confidence_cutoffs(self, plddt1, plddt2, pae)\n        + get_confident_interaction_map(self, region_of_interest)\n        + get_interacting_patches(self, contact_map, region_of_interest)\n        + save_ppair_interaction(self, region_of_interest, save_plot, plot_type, p1_name, p2_name, concat_residues, contact_probability)\n    }\n```","x":-2828,"y":-708,"width":760,"height":330,"color":"5"},
		{"alias":"get_interaction_data","collapsed":true,"id":"a2eea1af3c990ff5","type":"text","text":"```py\ndef get_interaction_data(self, region_of_interest: Dict):\n\t\"\"\"\n\tGet the interaction amp, pLDDT, and PAE for the region of interest.\n\n\tArgs:\n\t\tregion_of_interest (Dict): Dictionary containing the chain IDs and the residue numbers for the region of interest.\n\n\tReturns:\n\t\tinteraction_map (np.array): binary contact map or distance map\n\t\tplddt1 (np.array): plddt values for chain 1\n\t\tplddt2 (np.array): plddt values for chain 2\n\t\tpae (np.array): PAE matrix for the region of interest\n\t\"\"\"\n\n\tchain1, chain2 = list(region_of_interest.keys())\n\tp1_region, p2_region = region_of_interest[chain1], region_of_interest[chain2]\n\n\t# chain1 start and end indices.\n\tstart_idx1 = self.num_to_idx[chain1][p1_region[0]]\n\tend_idx1 = self.num_to_idx[chain1][p1_region[1]]\n\n\t# chain2 start and end indices.\n\tstart_idx2 = self.num_to_idx[chain2][p2_region[0]]\n\tend_idx2 = self.num_to_idx[chain2][p2_region[1]]\n\n\tavg_pae = self.avg_pae[start_idx1:end_idx1+1, start_idx2:end_idx2+1]\n\n\tcoords1 = np.array(self.coords_list[start_idx1:end_idx1+1])\n\tcoords2 = np.array(self.coords_list[start_idx2:end_idx2+1])\n\n\tplddt1 = {\n\t\tchain1: np.array(self.plddt_list[start_idx1:end_idx1+1])\n\t}\n\tplddt2 = {\n\t\tchain2: np.array(self.plddt_list[start_idx2:end_idx2+1])\n\t}\n\n\t# Create a contact map or distance map as specified.\n\tinteraction_map = get_interaction_map(\n\t\tcoords1=coords1.reshape(-1, 3),\n\t\tcoords2=coords2.reshape(-1, 3),\n\t\tcontact_threshold=self.contact_threshold,\n\t\tmap_type=self.interaction_map_type\n\t)\n\n\treturn interaction_map, plddt1, plddt2, avg_pae\n```","x":-3924,"y":-768,"width":950,"height":1075,"color":"3"},
		{"alias":"apply_confidence_cutoffs","collapsed":true,"id":"9289ab605522ff99","type":"text","text":"```py\ndef apply_confidence_cutoffs(\n\tself,\n\tplddt1: dict,\n\tplddt2: dict,\n\tpae: np.array\n):\n\t\"\"\"\n\tmask low-confidence interactions.\n\n\tArgs:\n\t\tplddt1 (dict): pLDDT values for chain 1\n\t\tplddt2 (dict): pLDDT values for chain 2\n\n\tReturns:\n\t\tplddt_matrix (np.array): binary matrix for plddt values >= plddt_cutoff\n\t\tpae (np.array): binary matrix for pae values <= pae_cutoff\n\t\"\"\"\n\n\tchain1, chain2 = next(iter(plddt1)), next(iter(plddt2))\n\tplddt1, plddt2 = plddt1[chain1], plddt2[chain2]\n\tplddt1, plddt2 = plddt1.reshape(-1, 1), plddt2.reshape(-1,1)\n\n\tch1_cutoff = ch2_cutoff = self.plddt_cutoff\n\tif chain1 in self.idr_chains:\n\t\tch1_cutoff = self.idr_plddt_cutoff\n\tif chain2 in self.idr_chains:\n\t\tch2_cutoff = self.idr_plddt_cutoff\n\n\tplddt1 = np.where(plddt1 >= ch1_cutoff, 1, 0)\n\tplddt2 = np.where(plddt2 >= ch2_cutoff, 1, 0)\n\tplddt_matrix = plddt1 * plddt2.T\n\n\tpae = np.where(pae <= self.pae_cutoff, 1, 0)\n\n\treturn plddt_matrix, pae\n```","x":-3771,"y":-708,"width":797,"height":838,"color":"3"},
		{"alias":"get_confident_interaction_map","collapsed":true,"id":"394f3b85731dbd32","type":"text","text":"```py\ndef get_confident_interaction_map(self, region_of_interest: Dict):\n\t\"\"\"\n\tFor the specified regions in the predicted structure, obtain all confident interacting residue pairs.\n\n\tReturns:\n\t\tconfident_interactions (np.array): binary map of confident interacting residues\n\t\"\"\"\n\n\tinteraction_map, plddt1, plddt2, avg_pae = self.get_interaction_data(\n\t\tregion_of_interest=region_of_interest\n\t)\n\n\tplddt_matrix, pae_matrix = self.apply_confidence_cutoffs(\n\t\tplddt1=plddt1, plddt2=plddt2, pae=avg_pae\n\t)\n\n\tconfident_interactions = interaction_map * plddt_matrix * pae_matrix\n\n\treturn confident_interactions\n```","x":-3882,"y":-648,"width":908,"height":524,"color":"3"},
		{"alias":"get_interacting_patches","collapsed":true,"id":"4e65eace47c4628e","type":"text","text":"```py\ndef get_interacting_patches(\n\tself,\n\tcontact_map: np.array,\n\tregion_of_interest: dict,\n):\n\t\"\"\"This is a dirty implementation to get the interacting patches. \\n\n\tThis is a temporary solution until we find a better way to get interacting\n\tpatches for the given contact map.\n\n\tArgs:\n\t\tcontact_map (np.array): binary contact map.\n\t\tregion_of_interest (dict): region of interest for the protein pair.\n\n\tReturns:\n\t\tpatches (dict): interacting patches for the given region of interest of the protein pair.\n\t\"\"\"\n\n\tpatches = {}\n\n\tchain1, chain2 = region_of_interest.keys()\n\tp1_region, p2_region = region_of_interest[chain1], region_of_interest[chain2]\n\n\tif np.unique(contact_map).tolist() == [0]: # No interactions found.\n\t\twarnings.warn(\n\t\t\tf\"No interacting patches found for {chain1}:{p1_region} and {chain2}:{p2_region}.\"\n\t\t)\n\t\treturn patches\n\n\tpatches_df = get_patches_from_matrix(\n\t\tmatrix=contact_map,\n\t\tchain1=chain1,\n\t\tchain2=chain2\n\t)\n\n\tfor patch_idx, patch in patches_df.iterrows():\n\n\t\tch1_patch = patch[chain1]\n\t\tch2_patch = patch[chain2]\n\n\t\tch1_patch = sorted([int(x) for x in ch1_patch])\n\t\tch2_patch = sorted([int(x) for x in ch2_patch])\n\n\t\tch1_patch = np.array(ch1_patch) + region_of_interest[chain1][0]\n\t\tch2_patch = np.array(ch2_patch) + region_of_interest[chain2][0]\n\n\t\t# patches[patch_idx] = {\n\t\t#     chain1: (\n\t\t#         f\"{ch1_patch[0]}-{ch1_patch[-1]}\"\n\t\t#         if len(ch1_patch) > 1\n\t\t#         else str(ch1_patch[0])\n\t\t#     ),\n\t\t#     chain2: (\n\t\t#         f\"{ch2_patch[0]}-{ch2_patch[-1]}\"\n\t\t#         if len(ch2_patch) > 1\n\t\t#         else str(ch2_patch[0])\n\t\t#     ),\n\t\t# }\n\n\t\tpatches[patch_idx] = {\n\t\t\tchain1: np.array(ch1_patch),\n\t\t\tchain2: np.array(ch2_patch),\n\t\t}\n\n\treturn patches\n```","x":-3913,"y":-588,"width":939,"height":1362,"color":"3"},
		{"alias":"save_ppair_interaction","collapsed":true,"id":"bc3b91e24f1ccfab","type":"text","text":"```py\ndef save_ppair_interaction(\n\tself,\n\tregion_of_interest: Dict,\n\tsave_plot: bool = False,\n\tplot_type: str = \"static\",\n\tp1_name: str | None = None,\n\tp2_name: str | None = None,\n\tconcat_residues: bool = True,\n\tcontact_probability: bool = True,\n):\n\t\"\"\"Save the interacting patches for the given region of interest of the protein pair.\n\n\tArgs:\n\t\tregion_of_interest (Dict): Dictionary containing the chain IDs and the residue indices for the region of interest.\n\t\tsave_plot (bool, optional): Outputs the plot if True. Defaults to False.\n\t\tplot_type (str, optional): Type of plot to be saved. Defaults to \"static\"; options: [\"static\", \"interactive\", \"both\"].\n\t\tp1_name (str, optional): Name of the first protein. Defaults to None.\n\t\tp2_name (str, optional): Name of the second protein. Defaults to None.\n\t\tconcat_residues (bool, optional): Whether to concatenate the residues into residue ranges. Defaults to True.\n\t\tcontact_probability (bool, optional): Whether to add contact probability column to the output. Defaults to True.\n\t\"\"\"\n\n\tchain1, chain2 = list(region_of_interest.keys())\n\tp1_region, p2_region = region_of_interest[chain1], region_of_interest[chain2]\n\n\tcontact_map = self.get_confident_interaction_map(\n\t\tregion_of_interest=region_of_interest\n\t)\n\n\tinteracting_patches = self.get_interacting_patches(\n\t\tcontact_map=contact_map,\n\t\tregion_of_interest=region_of_interest,\n\t)\n\n\tif p1_name and p2_name:\n\t\tp_names = {\n\t\t\tchain1: p1_name,\n\t\t\tchain2: p2_name,\n\t\t}\n\t\tdir_name_to_replace = \"_\".join([p1_name, p2_name])\n\telse:\n\t\tp_names = {\n\t\t\tchain1: chain1,\n\t\t\tchain2: chain2,\n\t\t}\n\t\tdir_name_to_replace = None\n\n\n\tif len(interacting_patches) > 0:\n\n\t\tfile_name = \"_\".join([\n\t\t\tf\"{p_names[k]}_{k}:{v[0]}-{v[1]}\" for k, v in region_of_interest.items()\n\t\t])\n\n\t\tif dir_name_to_replace:\n\t\t\tdir_name = os.path.basename(self.struct_file_path).split(\".\")[0]\n\t\t\t# self.output_dir = self.output_dir.replace(dir_name, dir_name_to_replace)\n\n\t\tos.makedirs(self.output_dir, exist_ok=True)\n\n\t\tsave_map(\n\t\t\tcontact_map=contact_map,\n\t\t\tavg_contact_probs_mat=self.avg_contact_probs_mat,\n\t\t\tpatches=interacting_patches,\n\t\t\tchain1=chain1,\n\t\t\tchain2=chain2,\n\t\t\tp1_name=p_names[chain1],\n\t\t\tp2_name=p_names[chain2],\n\t\t\tp1_region=p1_region,\n\t\t\tp2_region=p2_region,\n\t\t\tout_file=os.path.join(self.output_dir, f\"patches_{file_name}.html\"),\n\t\t\tsave_plot=save_plot,\n\t\t\tplot_type=plot_type,\n\t\t\tconcat_residues=concat_residues,\n\t\t\tcontact_probability=contact_probability,\n\t\t\tnum_to_idx=self.num_to_idx,\n\t\t\tidx_to_num=self.idx_to_num,\n\t\t)\n```","x":-4114,"y":-528,"width":1140,"height":1837,"color":"3"},
		{"alias":"create_regions_of_interest","collapsed":true,"id":"60e56fb5cf97166b","type":"text","text":"```py\ndef create_regions_of_interest(self):\n\t\"\"\"\n\tCreate regions of interest for all possible chain pairs.\n\n\tReturns:\n\t\tregions_of_interest (list): list of regions of interest\n\t\"\"\"\n\n\tregions_of_interest = []\n\ttoken_chain_ids = self.token_chain_ids\n\tchain_pairs = set()\n\n\tfor chain1 in set(token_chain_ids):\n\t\tfor chain2 in set(token_chain_ids):\n\t\t\tif chain1 != chain2:\n\t\t\t\tpair = tuple(sorted([chain1, chain2]))\n\t\t\t\tchain_pairs.add(pair)\n\n\tchain_pairs = list(chain_pairs)\n\n\tfor chain1, chain2 in chain_pairs:\n\n\t\tch1_start = self.renumber.renumber_chain_res_num(\n\t\t\tchain_res_num=1,\n\t\t\tchain_id=chain1\n\t\t)\n\t\tch1_end = self.renumber.renumber_chain_res_num(\n\t\t\tchain_res_num=self.lengths_dict[chain1],\n\t\t\tchain_id=chain1\n\t\t)\n\t\tch2_start = self.renumber.renumber_chain_res_num(\n\t\t\tchain_res_num=1,\n\t\t\tchain_id=chain2\n\t\t)\n\t\tch2_end = self.renumber.renumber_chain_res_num(\n\t\t\tchain_res_num=self.lengths_dict[chain2],\n\t\t\tchain_id=chain2\n\t\t)\n\n\t\tregion_of_interest = {\n\t\t\tchain1: [ch1_start, ch1_end],\n\t\t\tchain2: [ch2_start, ch2_end],\n\t\t}\n\n\t\t# region_of_interest = self.renumber.renumber_region_of_interest(\n\t\t#     region_of_interest=region_of_interest,\n\t\t# )\n\n\t\tregions_of_interest.append(region_of_interest)\n\n\treturn regions_of_interest\n```","x":-3731,"y":-833,"width":757,"height":1185,"color":"3"},
		{"alias":"filter_plddt","collapsed":true,"id":"ab2b183971db89c7","type":"text","text":"```py\ndef filter_plddt(\n\tself,\n\trb_dict: dict,\n\tpatch_threshold: int = 0,\n):\n\t\"\"\"Filter the residues in the rigid bodies based on the pLDDT cutoff.\n\t- If the pLDDT score of a residue is less than the cutoff, it is removed from the rigid body.\n\tArgs:\n\t\trb_dict (dict): dictionary of rigid bodies\n\t\tpatch_threshold (int): minimum number of contiguous residues for which the pLDDT score is above the cutoff\n\n\tReturns:\n\t\trb_dict (dict): dictionary of rigid bodies with residues filtered based on the pLDDT cutoff\n\t\"\"\"\n\n\t# Filter the residues in each chain in the rigid body based on the pLDDT cutoff\n\tfor chain_id, rb_res_num_list in rb_dict.items():\n\n\t\tconfident_residues = []\n\n\t\t# sorted list of residue numbers in the rigid body\n\t\trb_res_num_arr = np.array(sorted(rb_res_num_list))\n\n\t\t# sorted list of residue indices in the rigid body\n\t\tplddt_res_num_arr = np.array([self.num_to_idx[chain_id][res_num] for res_num in rb_res_num_list])\n\n\t\t# True/False array based on the pLDDT cutoff\n\t\t# for e.g. plddt_arr = [70, 78, 90, 65, 65, 80, 90]\n\t\t# tf_plddt_filtered = [True, True, True, False, False, True, True] for cutoff = 70\n\t\tif chain_id in self.idr_chains:\n\t\t\ttf_plddt_filtered = np.array(self.plddt_list)[plddt_res_num_arr] >= self.plddt_cutoff_idr\n\t\telse:\n\t\t\ttf_plddt_filtered = np.array(self.plddt_list)[plddt_res_num_arr] >= self.plddt_cutoff\n\n\t\t# Convert the pLDDT scores to True/False based on the threshold\n\t\t# for e.g. if arr = [True, False, False, False, True, True] and threshold = 3\n\t\t# the output will be [True, True, True, True, True, True]\n\t\ttf_plddt_filtered = convert_false_to_true(\n\t\t\tarr=tf_plddt_filtered,\n\t\t\tthreshold=patch_threshold,\n\t\t)\n\n\t\t# Get the residue numbers of the confident residues\n\t\tconfident_residues = rb_res_num_arr[tf_plddt_filtered]\n\t\trb_dict[chain_id] = confident_residues.tolist()\n\n\t# Remove chains which have no confident residues\n\tempty_chains = []\n\n\tfor chain_id, confident_residues in rb_dict.items():\n\t\tif len(confident_residues) == 0:\n\t\t\tempty_chains.append(chain_id)\n\n\tfor chain_id in empty_chains:\n\t\tdel rb_dict[chain_id]\n\n\treturn rb_dict\n```","x":-919,"y":-839,"width":1070,"height":1282,"color":"3"},
		{"alias":"extract_protein_chain_mapping","collapsed":true,"id":"91dc4275aa5beb82","type":"text","text":"```py\ndef extract_protein_chain_mapping(self, protein_chain_mapping: dict):\n\n\tprotein_chain_map = {}\n\n\tif protein_chain_mapping is None:\n\t\treturn protein_chain_map\n\n\tfor p_c_maps in protein_chain_mapping:\n\t\tprotein_name, chain_ids = p_c_maps.split(\":\")\n\t\tchain_ids = chain_ids.split(\",\")\n\t\tfor chain_id in chain_ids:\n\t\t\tif chain_id not in protein_chain_map:\n\t\t\t\tprotein_chain_map[chain_id] = protein_name\n\n\treturn protein_chain_map\n```","x":-919,"y":-779,"width":696,"height":426,"color":"3"},
		{"alias":"save_rigid_bodies","collapsed":true,"id":"a0c5358863c438d1","type":"text","text":"```py\ndef save_rigid_bodies(\n\tself,\n\tdomains: list,\n\toutput_dir: str,\n\toutput_format: str = \"txt\",\n\tsave_structure: bool = True,\n\tstructure_file_type: str = \"pdb\",\n\tno_plddt_filter_for_structure: bool = False,\n\tpae_plot: bool = False,\n\trb_assessment: dict | None = None,\n\tprotein_chain_map: dict | None = None,\n):\n\t\"\"\" Save the rigid bodies to a file and/or save the structure of the rigid bodies and assess the rigid bodies.\n\t- The rigid bodies are saved in a plain text format with the chain IDs and residue numbers.\n\t- The structure of the rigid bodies can be saved in PDB or CIF format. For rigid bodies with modifications, it is recommended to use PDB format.\n\t- The PAE plot can be saved to visualize the rigid bodies in the PAE matrix.\n\t- The rigid bodies can be assessed based on the interface residues, number of contacts, interface PAE and pLDDT, average PAE and plDDT and minimum PAE.\n\t- The assessment is saved in an Excel file.\n\n\tparameters for rigid body assessment:\\n\n\t- `as_average`: \\n\n\twhether to report only the average of assessment metric to the output file. Defaults to False. \\n\n\t- `symmetric_pae`: \\n\n\twhether to report a single average PAE value or assymetric PAE value for PAE assessment metrics. Defaults to False. \\n\n\n\tArgs:\n\t\tdomains (list): list of rigid bodies, where each rigid body is a dictionary with chain IDs as keys and residue numbers as values.\n\t\toutput_dir (str): Directory to save the output files.\n\t\toutput_format (str, optional): Defaults to \"txt\". (\"txt\" or \"csv\")\n\t\tsave_structure (bool, optional): Whether to save the structure of the rigid bodies. Defaults to True.\n\t\tstructure_file_type (str, optional): File type to save the structure. Defaults to \"pdb\". (\"pdb\" or \"cif\")\n\t\tno_plddt_filter_for_structure (bool, optional): Whether to save the structure without filtering based on pLDDT. Defaults to False.\n\t\tpae_plot (bool, optional): Whether to save the PAE plot for the rigid bodies. Defaults to False.\n\t\trb_assessment (dict | None, optional): Dictionary containing parameters for rigid body assessment.\n\t\"\"\"\n\n\tdir_name = os.path.basename(self.struct_file_path).split(\".\")[0]\n\toutput_dir = os.path.join(output_dir, dir_name)\n\n\tos.makedirs(output_dir, exist_ok=True)\n\n\tfile_name = (\n\t\tos.path.basename(self.struct_file_path).split(\".\")[0] + \"_rigid_bodies\"\n\t)\n\n\tprotein_chain_map = self.extract_protein_chain_mapping(protein_chain_mapping=protein_chain_map)\n\n\t##################################################\n\n\t# txt or csv output format\n\tif output_format == \"txt\":\n\t\tfile_name += \".txt\"\n\t\toutput_path = os.path.join(output_dir, file_name)\n\n\t\twith open(output_path, \"w\") as f:\n\n\t\t\tfor idx, rb_dict in enumerate(domains):\n\t\t\t\tf.write(f\"Rigid Body {idx}\\n\")\n\n\t\t\t\tfor chain_id, res_list in rb_dict.items():\n\n\t\t\t\t\tprotein_name = protein_chain_map.get(chain_id, None)\n\n\t\t\t\t\tif len(res_list) > 0:\n\t\t\t\t\t\tif protein_name:\n\t\t\t\t\t\t\tf.write(\n\t\t\t\t\t\t\t\tf\"{protein_name}_{chain_id}: {get_key_from_res_range(res_range=res_list)}\\n\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tf.write(\n\t\t\t\t\t\t\t\tf\"{chain_id}:{get_key_from_res_range(res_range=res_list)}\\n\"\n\t\t\t\t\t\t\t)\n\n\t\t\t\tf.write(\"\\n\")\n\n\telif output_format == \"csv\":\n\t\tfile_name += \".csv\"\n\t\toutput_path = os.path.join(output_dir, file_name)\n\n\t\trows = []\n\t\tfor idx, rb_dict in enumerate(domains):\n\t\t\tfor chain_id, res_list in rb_dict.items():\n\t\t\t\tif len(res_list) > 0:\n\t\t\t\t\tprotein_name = protein_chain_map.get(chain_id, None)\n\n\t\t\t\t\tif protein_name:\n\t\t\t\t\t\trows.append({\n\t\t\t\t\t\t\t\"Rigid Body\": idx,\n\t\t\t\t\t\t\t\"Chain ID\": chain_id,\n\t\t\t\t\t\t\t\"Protein Name\": protein_name,\n\t\t\t\t\t\t\t\"Residues\": get_key_from_res_range(res_range=res_list),\n\t\t\t\t\t\t})\n\t\t\t\t\telse:\n\t\t\t\t\t\trows.append({\n\t\t\t\t\t\t\t\"Rigid Body\": idx,\n\t\t\t\t\t\t\t\"Chain ID\": chain_id,\n\t\t\t\t\t\t\t\"Residues\": get_key_from_res_range(res_range=res_list),\n\t\t\t\t\t\t})\n\n\t\tdf = pd.DataFrame(rows)\n\t\tdf.to_csv(output_path, index=False)\n\n\telse:\n\t\traise ValueError(\n\t\t\tf\"Invalid output format: {output_format}. Use 'txt' or 'csv'.\"\n\t\t)\n\n\t##################################################\n\t# Save the structure of the rigid bodies\n\tif save_structure:\n\n\t\tif structure_file_type == \"cif\":\n\t\t\twarnings.warn(\n\t\t\t\t\"\"\"\n\t\t\t\tProtein or nucleotide modifications are stored as HETATM for which sequence connectivity\n\t\t\t\tis lost in CIF format. \\n\n\t\t\t\tPlease use PDB format to save the structure with modifications.\n\t\t\t\t\"\"\"\n\t\t\t)\n\n\t\t# Renumber the structure to match the actual sequence numbering if af_offset is provided\n\t\tstructure = self.renumber.renumber_structure(\n\t\t\tstructure=self.structureparser.structure,\n\t\t)\n\n\t\tfor idx, rb_dict in enumerate(domains):\n\n\t\t\t# In the following case, the txt or csv ouput will have pLDDT filtered residues\n\t\t\t# but, the structure file will ignore this filter\n\t\t\t# use this flag when you don't want missing residues in the structure file\n\t\t\tif no_plddt_filter_for_structure:\n\t\t\t\tfor chain_id, res_list in rb_dict.items():\n\t\t\t\t\tif len(res_list) > 0:\n\t\t\t\t\t\tres_list = fill_up_the_blanks(res_list)\n\t\t\t\t\t\trb_dict[chain_id] = res_list\n\n\t\t\toutput_path = os.path.join(output_dir, f\"rigid_body_{idx}.{structure_file_type}\")\n\n\t\t\tsave_structure_obj(\n\t\t\t\tstructure=structure,\n\t\t\t\tout_file=output_path,\n\t\t\t\tres_select_obj=ResidueSelect(rb_dict),\n\t\t\t\tsave_type=structure_file_type,\n\t\t\t\tpreserve_header_footer=False,\n\t\t\t)\n\n\t##################################################\n\t# Save the PAE plot for the rigid bodies\n\t# the region of the PAE matrix corresponding to the rigid bodies will be highlighted\n\tif pae_plot:\n\t\tfor rb_idx, rb_dict in enumerate(domains):\n\n\t\t\t# patches are the highlighted rectangles in the PAE matrix\n\t\t\tpatches = []\n\n\t\t\tfor chain_id1, res_list1 in rb_dict.items():\n\n\t\t\t\tfor chain_id2, res_list2 in rb_dict.items():\n\n\t\t\t\t\tres_idxs_1 = [\n\t\t\t\t\t\tself.num_to_idx[chain_id1][res_num] for res_num in res_list1\n\t\t\t\t\t]\n\t\t\t\t\tres_idxs_2 = [\n\t\t\t\t\t\tself.num_to_idx[chain_id2][res_num] for res_num in res_list2\n\t\t\t\t\t]\n\t\t\t\t\tres_idx_range_1 = get_key_from_res_range(res_range=res_idxs_1, as_list=True)\n\t\t\t\t\tres_idx_range_2 = get_key_from_res_range(res_range=res_idxs_2, as_list=True)\n\n\t\t\t\t\tfor res_idx_1 in res_idx_range_1:\n\n\t\t\t\t\t\tfor res_idx_2 in res_idx_range_2:\n\n\t\t\t\t\t\t\tif \"-\" in res_idx_1 and \"-\" in res_idx_2:\n\t\t\t\t\t\t\t\txy_ = (int(res_idx_2.split(\"-\")[0]), int(res_idx_1.split(\"-\")[0])) # xy (0,0) coordinates for the rectangle\n\t\t\t\t\t\t\t\th_ = int(res_idx_1.split(\"-\")[1]) - int(res_idx_1.split(\"-\")[0]) + 1 # patch height\n\t\t\t\t\t\t\t\tw_ = int(res_idx_2.split(\"-\")[1]) - int(res_idx_2.split(\"-\")[0]) + 1 # patch width\n\n\t\t\t\t\t\t\t\tif h_ > 0 and w_ > 0:\n\t\t\t\t\t\t\t\t\tpatches.append(\n\t\t\t\t\t\t\t\t\t\t[xy_, h_, w_]\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\tfig = plt.figure(figsize=(20, 20))\n\t\t\tplt.rcParams['font.size'] = 16\n\t\t\tplt.rcParams['axes.titlesize'] = 28\n\t\t\tplt.rcParams['axes.labelsize'] = 22\n\t\t\tplt.rcParams['xtick.labelsize'] = 13\n\t\t\tplt.rcParams['ytick.labelsize'] = 13\n\t\t\tplt.imshow(\n\t\t\t\tself.pae,\n\t\t\t\t# cmap=\"Greens_r\",\n\t\t\t\tcmap=\"Greys_r\",\n\t\t\t\tvmax=31.75,\n\t\t\t\tvmin=0,\n\t\t\t\tinterpolation=\"nearest\",\n\t\t\t\t)\n\n\t\t\tfor xy, h, w in patches:\n\t\t\t\trect = matplotlib.patches.Rectangle(\n\t\t\t\t\txy,\n\t\t\t\t\tw,\n\t\t\t\t\th,\n\t\t\t\t\tlinewidth=0,\n\t\t\t\t\t# edgecolor=\"green\",\n\t\t\t\t\tfacecolor=\"lime\",\n\t\t\t\t\talpha=0.5,\n\t\t\t\t)\n\t\t\t\tplt.gca().add_patch(rect)\n\n\t\t\tcumu_len = 0\n\t\t\tticks = []\n\t\t\tticks_labels = []\n\n\t\t\tfor chain_id, p_length in self.lengths_dict.items():\n\t\t\t\tif chain_id != \"total\":\n\t\t\t\t\tcumu_len += p_length\n\n\t\t\t\t\tif cumu_len != self.pae.shape[1]:\n\t\t\t\t\t\tplt.axhline(y=cumu_len, color='red', linestyle='--', linewidth=0.75)\n\t\t\t\t\t\tplt.axvline(x=cumu_len, color='red', linestyle='--', linewidth=0.75)\n\n\t\t\t\t\tif self.af_offset is not None:\n\n\t\t\t\t\t\tticks_labels.extend([\"\\n\" + f\"{self.af_offset[chain_id][0]}\" , f\"{self.af_offset[chain_id][1]}\" + \"\\n\" ])\n\t\t\t\t\t\tticks.extend([cumu_len-p_length, cumu_len]) if cumu_len-p_length not in ticks else ticks.extend([cumu_len-p_length+1, cumu_len])\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tticks_labels.extend([\"\\n\" + \"1\", f\"{self.lengths_dict[chain_id]}\" + \"\\n\"])\n\t\t\t\t\t\tticks.extend([cumu_len-p_length, cumu_len]) if cumu_len-p_length not in ticks else ticks.extend([cumu_len-p_length+1, cumu_len])\n\n\t\t\tplt.xlim(0, self.pae.shape[0])\n\t\t\tplt.ylim(0, self.pae.shape[1])\n\n\t\t\tplt.gca().invert_yaxis()\n\t\t\tplt.yticks(ticks, ticks_labels)\n\n\t\t\tplt.xticks(ticks, ticks_labels, rotation=90, ha='center')\n\t\t\tplt.title(f\"Predicted aligned error (PAE)\", pad=20)\n\t\t\tplt.xlabel(\"Scored residue\")\n\t\t\tplt.ylabel(\"Aligned residue\")\n\n\t\t\tax = plt.gca()\n\n\t\t\tdivider = make_axes_locatable(ax)\n\t\t\tcax = divider.append_axes(\"bottom\", size=\"5%\", pad=1.2)\n\t\t\tplt.colorbar(\n\t\t\t\tlabel=\"Predicted Alignment Error (PAE)\",\n\t\t\t\torientation=\"horizontal\",\n\t\t\t\tcax=cax,\n\t\t\t)\n\n\t\t\tplt.savefig(os.path.join(output_dir, f\"rigid_body_{rb_idx}.png\"), transparent=True)\n\t\t\tplt.close(fig)\n\n\t##################################################\n\t# Save the assessment of rigid bodies\n\tif rb_assessment:\n\n\t\t_start = time.time()\n\t\tprint(\"Assessing rigid bodies...\")\n\n\t\tassessment_file_name = (\n\t\t\tos.path.basename(self.struct_file_path).split(\".\")[0] + \"_rb_assessment.xlsx\"\n\t\t)\n\t\tsave_path = os.path.join(output_dir, assessment_file_name)\n\n\t\tcoords = np.array(self.coords_list)\n\n\t\tcontact_map = get_interaction_map(\n\t\t\tcoords1=coords,\n\t\t\tcoords2=coords,\n\t\t\tcontact_threshold=8,\n\t\t\tmap_type=\"contact\",\n\t\t)\n\n\t\tfor rb_idx, rb_dict in enumerate(domains):\n\n\t\t\trb_save_path = save_path.replace(\n\t\t\t\t\".xlsx\", f\"_rb_{rb_idx}.xlsx\"\n\t\t\t)\n\n\t\t\trb_assess = RigidBodyAssessment(\n\t\t\t\trb_dict=rb_dict,\n\t\t\t\tnum_to_idx=self.num_to_idx,\n\t\t\t\tidx_to_num=self.idx_to_num,\n\t\t\t\tcontact_map=contact_map,\n\t\t\t\tplddt_list=self.plddt_list,\n\t\t\t\tpae=self.pae,\n\t\t\t\tlengths_dict=self.lengths_dict,\n\t\t\t\tsave_path=rb_save_path,\n\t\t\t\tsymmetric_pae=rb_assessment.get(\"symmetric_pae\", False),\n\t\t\t\tas_average=rb_assessment.get(\"as_average\", False),\n\t\t\t\tidr_chains=self.idr_chains,\n\t\t\t\tprotein_chain_map=protein_chain_map,\n\t\t\t)\n\n\t\t\trb_assess.save_rb_assessment()\n\n\t\tprint(f\"Time taken to save rigid body assessment: {time.time() - _start:.2f} seconds\")\n```","x":-919,"y":-719,"width":1410,"height":6780,"color":"3"},
		{"alias":"save_rb_assessment","collapsed":true,"id":"c9cf8d4b8e6b7a5a","type":"text","text":"```py\ndef save_rb_assessment(self):\n\t\"\"\" Save the assessment of the rigid bodies to an Excel file.\n\n\tThe assessment includes:\n\t- Per chain assessment: Average pLDDT, Average iLDDT, Number of interface residues, Chain type (IDR or R)\n\t- Per chain pair assessment: Number of interface residues, Number of contacts, Average PAE, Average iPAE, Minimum PAE, Average iLDDT for each chain, Chain type (IDR or R) for each chain\n\t- Overall assessment: Average pLDDT, Average iLDDT, Number of interface residues, Chain type (IDR or R)\n\n\tThe assessment is saved in an Excel file with three sheets:\n\t- \"Chain Wise Assessment\": Contains per chain assessment data.\n\t- \"Chain Pairwise Assessment\": Contains per chain pair assessment data.\n\t- \"Overall Assessment\": Contains overall assessment data.\n\t\"\"\"\n\n\tchain_wise_assessment_rows = []\n\tchain_pairwise_assessment_rows = []\n\toverall_assessment_rows = []\n\n\tfor chain_id in self.unique_chains:\n\t\tchain_wise_assessment_rows.append({\n\t\t\t\"Chain ID\": chain_id,\n\t\t\t\"Protein Name\": self.protein_chain_map.get(chain_id, None),\n\t\t\t\"Average pLDDT\": self.per_chain_avg_plddt[chain_id],\n\t\t\t\"Average ipLDDT\": self.per_chain_avg_iplddt.get(chain_id, np.nan),\n\t\t\t\"Number of Interface Residues\": len(self.per_chain_interface_residues[chain_id]),\n\t\t\t\"Chain Type\": \"IDR\" if chain_id in self.idr_chains else \"R\",\n\t\t})\n\n\tfor chain_pair in self.chain_pairs:\n\t\tchain1, chain2 = chain_pair\n\n\t\tif self.as_average:\n\n\t\t\tif self.symmetric_pae:\n\t\t\t\tchain_pairwise_assessment_rows.append({\n\t\t\t\t\t\"Chain Pair\": f\"{chain1}-{chain2}\",\n\t\t\t\t\t\"Protein Name 1\": self.protein_chain_map.get(chain1, \"Unknown\"),\n\t\t\t\t\t\"Protein Name 2\": self.protein_chain_map.get(chain2, \"Unknown\"),\n\t\t\t\t\t\"Number of Interface Residues\": self.num_interface_residues[chain_pair],\n\t\t\t\t\t\"Number of Contacts\": self.num_contacts[chain_pair],\n\t\t\t\t\t\"Average PAE\": self.pairwise_avg_pae[chain_pair],\n\t\t\t\t\t\"Average iPAE\": self.pairwise_avg_ipae[chain_pair],\n\t\t\t\t\t\"Minimum PAE\": self.pairwise_min_pae[chain_pair],\n\t\t\t\t\t\"Average ipLDDT chain1\": self.pairwise_avg_iplddt[chain_pair].get(chain1, np.nan),\n\t\t\t\t\t\"Average ipLDDT chain2\": self.pairwise_avg_iplddt[chain_pair].get(chain2, np.nan),\n\t\t\t\t\t\"Chain Type 1\": \"IDR\" if chain1 in self.idr_chains else \"R\",\n\t\t\t\t\t\"Chain Type 2\": \"IDR\" if chain2 in self.idr_chains else \"R\",\n\t\t\t\t})\n\t\t\telse:\n\t\t\t\tchain_pairwise_assessment_rows.append({\n\t\t\t\t\t\"Chain Pair\": f\"{chain1}-{chain2}\",\n\t\t\t\t\t\"Protein Name 1\": self.protein_chain_map.get(chain1, \"Unknown\"),\n\t\t\t\t\t\"Protein Name 2\": self.protein_chain_map.get(chain2, \"Unknown\"),\n\t\t\t\t\t\"Number of Interface Residues\": self.num_interface_residues[chain_pair],\n\t\t\t\t\t\"Number of Contacts\": self.num_contacts[chain_pair],\n\t\t\t\t\t\"Average PAE ij\": self.pairwise_avg_pae[chain_pair][\"ij\"],\n\t\t\t\t\t\"Average PAE ji\": self.pairwise_avg_pae[chain_pair][\"ji\"],\n\t\t\t\t\t\"Average iPAE ij\": self.pairwise_avg_ipae[chain_pair][\"ij\"] if chain_pair in self.pairwise_avg_ipae else np.nan,\n\t\t\t\t\t\"Average iPAE ji\": self.pairwise_avg_ipae[chain_pair][\"ji\"] if chain_pair in self.pairwise_avg_ipae else np.nan,\n\t\t\t\t\t\"Minimum PAE ij\": self.pairwise_min_pae[chain_pair][\"ij\"] if chain_pair in self.pairwise_min_pae else np.nan,\n\t\t\t\t\t\"Minimum PAE ji\": self.pairwise_min_pae[chain_pair][\"ji\"] if chain_pair in self.pairwise_min_pae else np.nan,\n\t\t\t\t\t\"Average ipLDDT chain1\": self.pairwise_avg_iplddt[chain_pair].get(chain1, np.nan),\n\t\t\t\t\t\"Average ipLDDT chain2\": self.pairwise_avg_iplddt[chain_pair].get(chain2, np.nan),\n\t\t\t\t\t\"Chain Type 1\": \"IDR\" if chain1 in self.idr_chains else \"R\",\n\t\t\t\t\t\"Chain Type 2\": \"IDR\" if chain2 in self.idr_chains else \"R\",\n\t\t\t\t})\n\n\t\telse:\n\n\t\t\tif self.symmetric_pae:\n\t\t\t\tfor res1_idx, res2_idx in self.interface_res_pairs[chain_pair]:\n\t\t\t\t\tipae_val = (\n\t\t\t\t\t\tself.pairwise_ipae[chain_pair][\"ij\"].get((res1_idx, res2_idx), np.nan) +\n\t\t\t\t\t\tself.pairwise_ipae[chain_pair][\"ji\"].get((res2_idx, res1_idx), np.nan)\n\t\t\t\t\t) / 2\n\t\t\t\t\tchain_pairwise_assessment_rows.append({\n\t\t\t\t\t\t\"Chain Pair\": f\"{chain1}-{chain2}\",\n\t\t\t\t\t\t\"Protein Name 1\": self.protein_chain_map.get(chain1, \"Unknown\"),\n\t\t\t\t\t\t\"Protein Name 2\": self.protein_chain_map.get(chain2, \"Unknown\"),\n\t\t\t\t\t\t\"Residue Pair\": f\"{res1_idx}-{res2_idx}\",\n\t\t\t\t\t\t\"iPAE\": ipae_val,\n\t\t\t\t\t\t\"ipLDDT res1\": self.per_chain_iplddt[chain1].get(res1_idx, np.nan),\n\t\t\t\t\t\t\"ipLDDT res2\": self.per_chain_iplddt[chain2].get(res2_idx, np.nan),\n\t\t\t\t\t\t\"Chain Type 1\": \"IDR\" if chain1 in self.idr_chains else \"R\",\n\t\t\t\t\t\t\"Chain Type 2\": \"IDR\" if chain2 in self.idr_chains else \"R\",\n\t\t\t\t\t})\n\t\t\telse:\n\t\t\t\tfor res1_idx, res2_idx in self.interface_res_pairs[chain_pair]:\n\t\t\t\t\tipae_ij = self.pairwise_ipae[chain_pair][\"ij\"].get((res1_idx, res2_idx), np.nan)\n\t\t\t\t\tipae_ji = self.pairwise_ipae[chain_pair][\"ji\"].get((res2_idx, res1_idx), np.nan)\n\t\t\t\t\tchain_pairwise_assessment_rows.append({\n\t\t\t\t\t\t\"Chain Pair\": f\"{chain1}-{chain2}\",\n\t\t\t\t\t\t\"Protein Name 1\": self.protein_chain_map.get(chain1, \"Unknown\"),\n\t\t\t\t\t\t\"Protein Name 2\": self.protein_chain_map.get(chain2, \"Unknown\"),\n\t\t\t\t\t\t\"Residue Pair\": f\"{res1_idx}-{res2_idx}\",\n\t\t\t\t\t\t\"iPAE ij\": ipae_ij,\n\t\t\t\t\t\t\"iPAE ji\": ipae_ji,\n\t\t\t\t\t\t\"ipLDDT res1\": self.per_chain_iplddt[chain1].get(res1_idx, np.nan),\n\t\t\t\t\t\t\"ipLDDT res2\": self.per_chain_iplddt[chain2].get(res2_idx, np.nan),\n\t\t\t\t\t\t\"Chain Type 1\": \"IDR\" if chain1 in self.idr_chains else \"R\",\n\t\t\t\t\t\t\"Chain Type 2\": \"IDR\" if chain2 in self.idr_chains else \"R\",\n\t\t\t\t\t})\n\n\toverall_assessment_keys = {\n\t\t\"Number of Chains\": \"num_chains\",\n\t\t\"Number of Interacting Chain Pairs\": \"num_interacting_chain_pairs\",\n\t\t\"Number of Interface Residues\": \"num_interface_residues\",\n\t\t\"Number of Contacts\": \"num_contacts\",\n\t\t\"Average ipLDDT\": \"avg_iplddt\",\n\t\t\"Average IDR ipLDDT\": \"avg_idr_iplddt\",\n\t\t\"Average iPAE ij\": \"avg_ipae_ij\",\n\t\t\"Average iPAE ji\": \"avg_ipae_ji\",\n\t}\n\n\tfor col_head, key in overall_assessment_keys.items():\n\t\tif self.overall_assessment.get(key, np.nan) is not np.nan:\n\t\t\toverall_assessment_rows.append({\n\t\t\t\t\"Key\": col_head,\n\t\t\t\t\"Value\": self.overall_assessment.get(key)\n\t\t\t})\n\n\tchain_pairwise_assessment_df = pd.DataFrame(chain_pairwise_assessment_rows)\n\tchainwise_assessment_df = pd.DataFrame(chain_wise_assessment_rows)\n\toverall_assessment_df = pd.DataFrame(overall_assessment_rows)\n\n\tdf_dict = {\n\t\t\"chain_pairwise_assessment\": chain_pairwise_assessment_df,\n\t\t\"chainwise_assessment\": chainwise_assessment_df,\n\t\t\"overall_assessment\": overall_assessment_df,\n\t}\n\n\tfor k, df_ in df_dict.items():\n\t\tdf_dict[k] = df_.fillna(np.nan)\n\t\tdf_dict[k] = df_.map(lambda x: round(x, 2) if isinstance(x, (int, float)) else x)\n\n\twith pd.ExcelWriter(self.save_path, engine='openpyxl', mode='w') as writer:\n\t\tfor sheet_name, df in df_dict.items():\n\n\t\t\tif df.empty:\n\t\t\t\twarnings.warn(f\"Skipping empty DataFrame for sheet: {sheet_name}\")\n\t\t\t\tcontinue\n\n\t\t\tdf.to_excel(\n\t\t\t\twriter,\n\t\t\t\tsheet_name=sheet_name,\n\t\t\t\tindex=False,\n\t\t\t)\n```","x":-919,"y":-619,"width":1218,"height":3309,"color":"3"},
		{"collapsed":true,"id":"50170a2e5fddc142","type":"text","text":"```py\nclass RigidBodies(_Initialize)\n```\n\n```mermaid\nclassDiagram\n    class RigidBodies {\n        - __init__(self, data_path, structure_path, af_offset, idr_chains, **kwargs) None\n        + predict_domains(self, num_res, num_proteins, plddt_filter)\n        + domain_to_rb_dict(self, domain)\n        + filter_plddt(self, rb_dict, patch_threshold)\n        + extract_protein_chain_mapping(self, protein_chain_mapping)\n        + save_rigid_bodies(self, domains, output_dir, output_format, save_structure, structure_file_type, no_plddt_filter_for_structure, pae_plot, rb_assessment, protein_chain_map)\n    }\n```","alias":"RigidBodies.RigidBodies","x":-1969,"y":-709,"width":825,"height":272,"color":"5"},
		{"alias":"get_unique_chains","collapsed":true,"id":"017a1b44699d1497","type":"text","text":"```py\ndef get_unique_chains(self):\n\t\"\"\"Get unique chains in the rigid body.\n\n\tReturns:\n\t\tunique_chains (list): List of unique chain IDs in the rigid body.\n\t\"\"\"\n\n\tunique_chains = [\n\t\tchain_id\n\t\tfor chain_id in self.rb_dict.keys()\n\t\tif len(self.rb_dict[chain_id]) > 0\n\t]\n\n\treturn unique_chains\n```","x":-919,"y":-559,"width":730,"height":400,"color":"3"},
		{"alias":"get_chain_paris","collapsed":true,"id":"454d0aa6a0db65a7","type":"text","text":"```py\ndef get_chain_pairs(self):\n\t\"\"\"Get all unique chain pairs in the rigid body.\n\n\tReturns:\n\t\tchain_pairs (list): List of tuples containing unique chain pairs.\n\t\tEach tuple contains two chain IDs.\n\t\"\"\"\n\n\tchain_pairs = list(combinations(self.unique_chains, 2))\n\n\treturn [tuple(pair) for pair in chain_pairs]\n```","x":-919,"y":-499,"width":730,"height":324,"color":"3"},
		{"alias":"get_rb_res_binary_map","collapsed":true,"id":"9670c32e6dec70e8","type":"text","text":"```py\ndef get_rb_res_binary_map(self, lengths_dict):\n\t\"\"\"Get a binary map of residues in the rigid body.\n\n\tReturns:\n\t\trb_res_binary_map (np.ndarray): A binary map of residues in the rigid body.\n\t\tThe shape is (total_length, total_length) where total_length is the sum of lengths of all chains.\n\t\tThe value is 1 if the residue is part of the rigid body, 0 otherwise.\n\t\"\"\"\n\n\ttotal_len = lengths_dict.get(\"total\", 0)\n\trb_res_binary_map = np.zeros((total_len, total_len), dtype=int)\n\tall_rb_interface_res_idxs = []\n\n\tfor chain_id, res_list in self.rb_dict.items():\n\n\t\tres_idxs = [self.num_to_idx[chain_id][res_num] for res_num in res_list]\n\t\tall_rb_interface_res_idxs.extend(res_idxs)\n\n\tall_rb_interface_res_idxs = np.unique(all_rb_interface_res_idxs)\n\n\trb_res_binary_map[\n\t\tnp.ix_(all_rb_interface_res_idxs, all_rb_interface_res_idxs)\n\t] = 1\n\n\treturn rb_res_binary_map\n```","x":-919,"y":-439,"width":975,"height":630,"color":"3"},
		{"alias":"get_rb_res_pairs","collapsed":true,"id":"17f88e2ededc532f","type":"text","text":"```py\ndef get_rb_res_pairs(self):\n\t\"\"\"Get all unique residue pairs in the rigid body.\n\n\tReturns:\n\t\trb_res_pairs (defaultdict): A dictionary where keys are chain pairs (tuples) and values are lists of residue index pairs.\n\t\tEach residue index pair is a tuple of indices from the two chains in the rigid body.\n\t\"\"\"\n\n\trb_res_pairs = defaultdict(list)\n\n\tfor chain_pair in self.chain_pairs:\n\n\t\tchain1, chain2 = chain_pair\n\n\t\tres1_list = self.rb_dict[chain1]\n\t\tres2_list = self.rb_dict[chain2]\n\n\t\tres1_idxs = [self.num_to_idx[chain1][res_num] for res_num in res1_list]\n\t\tres2_idxs = [self.num_to_idx[chain2][res_num] for res_num in res2_list]\n\n\t\t# Create pairs of residues from the two chains\n\t\tpairs = list(product(res1_idxs, res2_idxs))\n\t\trb_res_pairs[chain_pair].extend(pairs)\n\n\treturn rb_res_pairs\n```","x":-919,"y":-379,"width":1197,"height":633,"color":"3"},
		{"alias":"get_interface_res_pairs","collapsed":true,"id":"a64e26126101120b","type":"text","text":"```py\ndef get_interface_res_pairs(\n\tself,\n\tcontact_map: np.ndarray,\n):\n\t\"\"\" Get interface residue pairs from the contact map.\n\n\tArgs:\n\t\tcontact_map (np.ndarray): A binary contact map where 1 indicates a contact between residues and 0 indicates no contact.\n\n\tReturns:\n\t\tinterface_res_pairs (defaultdict): A dictionary where keys are chain pairs (tuples) and values are lists of residue index pairs.\n\t\"\"\"\n\n\tinterface_res_pairs = defaultdict(list)\n\tcontacting_res_indices = np.argwhere(contact_map == 1)\n\n\tfor chain1, chain2 in tqdm(self.chain_pairs):\n\n\t\tres1_list = self.rb_dict[chain1]\n\t\tres2_list = self.rb_dict[chain2]\n\n\t\tres1_idxs = [self.num_to_idx[chain1][res_num] for res_num in res1_list]\n\t\tres2_idxs = [self.num_to_idx[chain2][res_num] for res_num in res2_list]\n\n\t\tmask1 = np.isin(contacting_res_indices[:, 0], res1_idxs)\n\t\tmask2 = np.isin(contacting_res_indices[:, 1], res2_idxs)\n\n\t\tmask = mask1 & mask2\n\t\tcontacting_res_pairs = set(\n\t\t\tmap(tuple, contacting_res_indices[mask])\n\t\t)\n\n\t\tif len(contacting_res_pairs) > 0:\n\t\t\tinterface_res_pairs[(chain1, chain2)].extend(\n\t\t\t\tlist(contacting_res_pairs)\n\t\t\t)\n\n\treturn interface_res_pairs\n```","x":-919,"y":-319,"width":1164,"height":920,"color":"3"},
		{"alias":"get_per_chain_interface_residues","collapsed":true,"id":"77a43d29d2a2db4c","type":"text","text":"```py\ndef get_per_chain_interface_residues(self):\n\t\"\"\"Get interface residues for each chain.\n\n\tReturns:\n\t\tper_chain_interface_residues (defaultdict): A dictionary where keys are chain IDs and values are lists of residue indices.\n\t\tEach list contains the indices of residues that are part of any of the interfaces that the chain is involved in.\n\t\"\"\"\n\n\tper_chain_interface_residues = defaultdict(list)\n\n\tfor chain_pair, interacting_res_pairs in self.interface_res_pairs.items():\n\n\t\tchain1, chain2 = chain_pair\n\n\t\tfor res1_idx, res2_idx in interacting_res_pairs:\n\n\t\t\tper_chain_interface_residues[chain1].append(\n\t\t\t\tres1_idx\n\t\t\t) if res1_idx not in per_chain_interface_residues[chain1] else None\n\n\t\t\tper_chain_interface_residues[chain2].append(\n\t\t\t\tres2_idx\n\t\t\t) if res2_idx not in per_chain_interface_residues[chain2] else None\n\n\treturn per_chain_interface_residues\n```","x":-919,"y":-259,"width":1185,"height":657,"color":"3"},
		{"alias":"RigidBodies.RigidBodyAssessment","collapsed":true,"id":"f903b8ed5a2c17ac","type":"text","text":"```py\nclass RigidBodyAssessment\n```\n\n```mermaid\nclassDiagram\n    class RigidBodyAssessment {\n        - __init__(self, rb_dict, num_to_idx, idx_to_num, contact_map, plddt_list, pae, lengths_dict, save_path, **kwargs) None\n        + save_rb_assessment(self)\n        + get_unique_chains(self)\n        + get_chain_pairs(self)\n        + get_rb_res_binary_map(self, lengths_dict)\n        + get_rb_res_pairs(self)\n        + get_interface_res_pairs(self, contact_map)\n        + get_per_chain_interface_residues(self)\n        + get_num_interface_residues(self)\n        + get_num_contacts(self)\n        + get_per_chain_plddt(self, plddt_list)\n        + get_per_chain_avg_plddt(self)\n        + get_per_chain_iplddt(self, plddt_list)\n        + get_per_chain_average_iplddt(self)\n        + get_pairwise_pae(self, pae)\n        + get_pairwise_avg_pae(self, symmetric_pae)\n        + get_pairwise_min_pae(self, symmetric_pae)\n        + get_pairwise_ipae(self, pae)\n        + get_pairwise_avg_ipae(self, symmetric_pae)\n        + get_pairwise_avg_iplddt(self)\n        + get_overall_assessment(self)\n    }\n```","x":-1974,"y":-319,"width":835,"height":598,"color":"5"},
		{"alias":"get_num_interface_residues","collapsed":true,"id":"f22183525769e578","type":"text","text":"```py\ndef get_num_interface_residues(self):\n\t\"\"\"Get the number of interface residues for each chain pair.\n\n\tReturns:\n\t\tnum_interface_residues (defaultdict): A dictionary where keys are chain pairs (tuples) and values are the number of unique interface residues.\n\t\tEach key is a tuple of two chain IDs, and the value is the count of unique residues that interact between those chains.\n\t\"\"\"\n\n\tnum_interface_residues = defaultdict(int)\n\n\tfor chain_pair, interacting_res_pairs in self.interface_res_pairs.items():\n\n\t\tunique_interface_residues = np.unique(np.array(interacting_res_pairs).flatten())\n\t\tnum_interface_residues[chain_pair] = len(unique_interface_residues)\n\n\treturn num_interface_residues\n```","x":-919,"y":-199,"width":987,"height":487,"color":"3"},
		{"alias":"get_num_contacts","collapsed":true,"id":"64da089e2309156e","type":"text","text":"```py\ndef get_num_contacts(self):\n\t\"\"\"Get the number of contacts for each chain pair.\n\n\tReturns:\n\t\tnum_contacts (defaultdict): A dictionary where keys are chain pairs (tuples) and values are the number of contacts.\n\t\tEach key is a tuple of two chain IDs, and the value is the count of contacts between those chains.\n\t\"\"\"\n\n\tnum_contacts = defaultdict(int)\n\n\tfor chain_pair, interacting_res_pairs in self.interface_res_pairs.items():\n\n\t\tnum_contacts[chain_pair] = len(interacting_res_pairs)\n\n\treturn num_contacts\n```","x":-919,"y":-139,"width":1075,"height":433,"color":"3"},
		{"alias":"get_per_chain_plddt","collapsed":true,"id":"1d5072fdcf17c7c9","type":"text","text":"```py\ndef get_per_chain_plddt(self, plddt_list):\n\t\"\"\" Get per-chain pLDDT scores from a list of pLDDT scores.\n\n\tArgs:\n\t\tplddt_list (list): A list of pLDDT scores for all residues in the structure.\n\n\tReturns:\n\t\tper_chain_plddt (defaultdict): A dictionary where keys are chain IDs and values are numpy arrays of pLDDT scores for residues in that chain.\n\t\"\"\"\n\n\tper_chain_plddt = defaultdict(np.ndarray)\n\n\tfor chain_id, res_list in self.rb_dict.items():\n\n\t\tres_idxs = [\n\t\t\tself.num_to_idx[chain_id][res_num] for res_num in res_list\n\t\t]\n\n\t\tplddt_scores = np.array(plddt_list)[res_idxs]\n\t\tper_chain_plddt[chain_id] = plddt_scores\n\n\treturn per_chain_plddt\n```","x":-919,"y":-79,"width":1168,"height":569,"color":"3"},
		{"alias":"get_per_chain_avg_plddt","collapsed":true,"id":"b81fd2fba386812e","type":"text","text":"```py\ndef get_per_chain_avg_plddt(self):\n\t\"\"\" Get the average pLDDT score for each chain.\n\n\tReturns:\n\t\tper_chain_avg_plddt (dict): A dictionary where keys are chain IDs and values are the average pLDDT scores for that chain.\n\t\"\"\"\n\n\treturn {\n\t\tchain_id: np.mean(plddt_scores)\n\t\tfor chain_id, plddt_scores in self.per_chain_plddt.items()\n\t}\n```","x":-919,"y":-19,"width":1013,"height":344,"color":"3"},
		{"alias":"get_per_chain_iplddt","collapsed":true,"id":"5f3184d9b368f615","type":"text","text":"```py\ndef get_per_chain_iplddt(self, plddt_list):\n\t\"\"\" Get per-chain ipLDDT scores from a list of pLDDT scores.\n\n\tArgs:\n\t\tplddt_list (list): A list of pLDDT scores for all residues in the structure.\n\n\tReturns:\n\t\tper_chain_iplddt (defaultdict): A dictionary where keys are chain IDs and values are dictionaries mapping residue indices to their pLDDT scores.\n\t\"\"\"\n\n\tper_chain_iplddt = defaultdict(dict)\n\n\tfor chain_id, interface_res_idxs in self.per_chain_interface_residues.items():\n\n\t\tfor res_idx in interface_res_idxs:\n\n\t\t\tper_chain_iplddt[chain_id][res_idx] = plddt_list[res_idx]\n\n\treturn per_chain_iplddt\n```","x":-919,"y":41,"width":1106,"height":530,"color":"3"},
		{"alias":"get_per_chain_avg_plddt","collapsed":true,"id":"196d5dbfb56f35c0","type":"text","text":"```py\ndef get_per_chain_average_iplddt(self):\n\t\"\"\" Get the average ipLDDT score for each chain.\n\n\tReturns:\n\t\tper_chain_avg_iplddt (dict): A dictionary where keys are chain IDs and values are the average ipLDDT scores for that chain.\n\t\"\"\"\n\n\treturn {\n\t\tchain_id: np.mean(list(iplddt_scores.values()))\n\t\tfor chain_id, iplddt_scores in self.per_chain_iplddt.items()\n\t}\n```","x":-919,"y":101,"width":928,"height":340,"color":"3"},
		{"alias":"get_pairwise_pae","collapsed":true,"id":"7c93f583f3c8e398","type":"text","text":"```py\ndef get_pairwise_pae(self, pae):\n\t\"\"\" Get pairwise PAE values for each chain pair.\n\n\tArgs:\n\t\tpae (np.ndarray): A 2D numpy array representing the predicted aligned error (PAE) matrix.\n\n\tReturns:\n\t\tpairwise_pae (defaultdict): A dictionary where keys are chain pairs (tuples) and values are dictionaries containing PAE values for residue pairs.\n\t\"\"\"\n\n\tpairwise_pae = defaultdict(np.ndarray)\n\n\tfor chain_pair in self.chain_pairs:\n\n\t\trb_chain_pair_res = self.rb_res_pairs[chain_pair]\n\n\t\trb_pae_vals_ij = [\n\t\t\tpae[res1_idx, res2_idx] for res1_idx, res2_idx in rb_chain_pair_res\n\t\t]\n\n\t\trb_pae_vals_ji = [\n\t\t\tpae[res2_idx, res1_idx] for res1_idx, res2_idx in rb_chain_pair_res\n\t\t]\n\n\t\tif len(rb_pae_vals_ij) > 0:\n\t\t\tpairwise_pae[chain_pair] = {\n\t\t\t\t\"ij\": rb_pae_vals_ij,\n\t\t\t\t\"ji\": rb_pae_vals_ji,\n\t\t\t}\n\n\treturn pairwise_pae\n```","x":-919,"y":161,"width":1178,"height":776,"color":"3"},
		{"alias":"get_pairwise_avg_pae","collapsed":true,"id":"0ba26850061961b8","type":"text","text":"```py\ndef get_pairwise_avg_pae(self, symmetric_pae: bool = False):\n\t\"\"\" Get the average PAE for each chain pair.\n\n\tArgs:\n\t\tsymmetric_pae (bool, optional): If True, calculates the average PAE symmetrically for both directions (ij and ji).\n\n\tReturns:\n\t\tpairwise_avg_pae (defaultdict): A dictionary where keys are chain pairs (tuples) and values are the average PAE values.\n\t\"\"\"\n\n\tif symmetric_pae:\n\t\tpairwise_avg_pae = defaultdict(float)\n\telse:\n\t\tpairwise_avg_pae = defaultdict(dict)\n\n\tfor chain_pair in self.chain_pairs:\n\t\tif symmetric_pae:\n\t\t\tpairwise_avg_pae[chain_pair] = (\n\t\t\t\tnp.mean(\n\t\t\t\t\tself.pairwise_pae[chain_pair][\"ij\"] +\n\t\t\t\t\tself.pairwise_pae[chain_pair][\"ji\"]\n\t\t\t\t) / 2\n\t\t\t)\n\t\telse:\n\t\t\tpairwise_avg_pae[chain_pair][\"ij\"] = np.mean(self.pairwise_pae[chain_pair][\"ij\"])\n\t\t\tpairwise_avg_pae[chain_pair][\"ji\"] = np.mean(self.pairwise_pae[chain_pair][\"ji\"])\n\n\treturn pairwise_avg_pae\n```","x":-919,"y":221,"width":1165,"height":707,"color":"3"},
		{"alias":"get_pairwise_min_pae","collapsed":true,"id":"0303f761ebdcb514","type":"text","text":"```py\ndef get_pairwise_min_pae(self, symmetric_pae: bool = False):\n\t\"\"\"Get the minimum PAE for each chain pair.\n\n\tArgs:\n\t\tsymmetric_pae (bool, optional): If True, calculates the minimum PAE symmetrically for both directions (ij and ji).\n\n\tReturns:\n\t\tpairwise_min_pae (defaultdict): A dictionary where keys are chain pairs (tuples) and values are the minimum PAE values.\n\t\tIf symmetric_pae is True, the minimum PAE is calculated as the minimum of both directions (ij and ji).\n\t\tIf symmetric_pae is False, the minimum PAE is calculated separately for each direction.\n\t\"\"\"\n\n\tif symmetric_pae:\n\t\tpairwise_min_pae = defaultdict(float)\n\telse:\n\t\tpairwise_min_pae = defaultdict(dict)\n\n\tfor chain_pair, pae_dict in self.pairwise_pae.items():\n\t\tif symmetric_pae:\n\t\t\tpairwise_min_pae[chain_pair] = np.min(\n\t\t\t\tnp.min(pae_dict[\"ij\"]), np.min(pae_dict[\"ji\"])\n\t\t\t)\n\t\telse:\n\t\t\tpairwise_min_pae[chain_pair][\"ij\"] = np.min(pae_dict[\"ij\"])\n\t\t\tpairwise_min_pae[chain_pair][\"ji\"] = np.min(pae_dict[\"ji\"])\n\n\treturn pairwise_min_pae\n```","x":-919,"y":281,"width":1230,"height":664,"color":"3"},
		{"alias":"get_pairwise_ipae","collapsed":true,"id":"d566466180d9574b","type":"text","text":"```py\ndef get_pairwise_ipae(self, pae):\n\t\"\"\" Get pairwise iPAE values for each chain pair.\n\n\tArgs:\n\t\tpae (np.ndarray): A 2D numpy array representing the predicted aligned error (PAE) matrix.\n\n\tReturns:\n\t\tpairwise_ipae (defaultdict): A dictionary where keys are chain pairs (tuples) and values are dictionaries containing iPAE values for residue pairs.\n\t\"\"\"\n\n\tpairwise_ipae = defaultdict(dict)\n\n\tfor chain_pair, interacting_res_pairs in self.interface_res_pairs.items():\n\n\t\tpairwise_ipae[chain_pair] = {\n\t\t\t\"ij\" : {\n\t\t\t\t(res1_idx, res2_idx): pae[res1_idx, res2_idx]\n\t\t\t\tfor res1_idx, res2_idx in interacting_res_pairs\n\t\t\t},\n\t\t\t\"ji\" : {\n\t\t\t\t(res2_idx, res1_idx): pae[res2_idx, res1_idx]\n\t\t\t\tfor res1_idx, res2_idx in interacting_res_pairs\n\t\t\t}\n\t\t}\n\n\treturn pairwise_ipae\n```","x":-919,"y":341,"width":1273,"height":673,"color":"3"},
		{"alias":"get_pairwise_avg_ipae","collapsed":true,"id":"f038790f1222ec79","type":"text","text":"```py\ndef get_pairwise_avg_ipae(self, symmetric_pae: bool = False):\n\t\"\"\" Get the average iPAE for each chain pair.\n\n\tArgs:\n\t\tsymmetric_pae (bool, optional): If True, calculates the average iPAE symmetrically for both directions (ij and ji).\n\n\tReturns:\n\t\tpairwise_avg_ipae (defaultdict): A dictionary where keys are chain pairs (tuples) and values are the average iPAE values.\n\t\"\"\"\n\n\tif symmetric_pae:\n\t\tpairwise_avg_ipae = defaultdict(float)\n\telse:\n\t\tpairwise_avg_ipae = defaultdict(dict)\n\n\tfor chain_pair, ipae_dict in self.pairwise_ipae.items():\n\n\t\tif symmetric_pae:\n\t\t\tpairwise_avg_ipae[chain_pair] = (\n\t\t\t\tnp.mean(list(ipae_dict[\"ij\"].values()) + list(ipae_dict[\"ji\"].values())) / 2\n\t\t\t)\n\t\telse:\n\t\t\tpairwise_avg_ipae[chain_pair][\"ij\"] = np.mean(list(ipae_dict[\"ij\"].values()))\n\t\t\tpairwise_avg_ipae[chain_pair][\"ji\"] = np.mean(list(ipae_dict[\"ji\"].values()))\n\n\treturn pairwise_avg_ipae\n```","x":-919,"y":401,"width":1125,"height":670,"color":"3"},
		{"alias":"get_pairwise_avg_iplddt","collapsed":true,"id":"d568fcad1a5ea0ae","type":"text","text":"```py\ndef get_pairwise_avg_iplddt(self):\n\t\"\"\" Get the average ipLDDT for each chain pair.\n\n\tReturns:\n\t\tpairwise_avg_iplddt (defaultdict): A dictionary where keys are chain pairs (tuples) and values are dictionaries containing average ipLDDT values for each chain in the pair.\n\t\"\"\"\n\n\tpairwise_avg_iplddt = defaultdict(dict)\n\n\tfor chain_pair, interacting_res_pairs in self.interface_res_pairs.items():\n\n\t\tchain1, chain2 = chain_pair\n\n\t\tiplddt1_values = [\n\t\t\tself.per_chain_iplddt[chain1].get(res1_idx, np.nan)\n\t\t\tfor res1_idx, res2_idx in interacting_res_pairs\n\t\t]\n\n\t\tiplddt2_values = [\n\t\t\tself.per_chain_iplddt[chain2].get(res2_idx, np.nan)\n\t\t\tfor res1_idx, res2_idx in interacting_res_pairs\n\t\t]\n\n\t\tpairwise_avg_iplddt[chain_pair][chain1] = np.mean(iplddt1_values)\n\t\tpairwise_avg_iplddt[chain_pair][chain2] = np.mean(iplddt2_values)\n\n\treturn pairwise_avg_iplddt\n```","x":-919,"y":461,"width":969,"height":694,"color":"3"},
		{"alias":"get_overall_assessment","collapsed":true,"id":"25e23fe01c2facf1","type":"text","text":"```py\ndef get_overall_assessment(self):\n\t\"\"\" Get overall assessment of the rigid body.\n\n\tReturns:\n\t\toverall_assessment (dict): A dictionary containing overall statistics about the rigid body.\n\t\tIt includes the number of chains, number of interacting chain pairs, number of interface residues,\n\t\tnumber of contacts, average ipLDDT, average IDR ipLDDT, average iPAE ij, and average iPAE ji.\n\t\"\"\"\n\n\toverall_assessment = {}\n\n\toverall_assessment[\"num_chains\"] = len(self.unique_chains)\n\n\toverall_assessment[\"num_interacting_chain_pairs\"] = len(self.interface_res_pairs)\n\n\toverall_assessment[\"num_interface_residues\"] = sum(\n\t\tlen(res_list)\n\t\tfor res_list in self.per_chain_interface_residues.values()\n\t)\n\n\toverall_assessment[\"num_contacts\"] = sum(\n\t\tlen(contact_pairs)\n\t\tfor contact_pairs in self.interface_res_pairs.values()\n\t)\n\n\tglobal_iplddt_scores = [\n\t\tiplddt\n\t\tfor iplddt_scores in self.per_chain_iplddt.values()\n\t\tfor iplddt in iplddt_scores.values()\n\t]\n\n\toverall_assessment[\"avg_iplddt\"] = (\n\t\tnp.mean(global_iplddt_scores) if global_iplddt_scores else np.nan\n\t)\n\n\tglobal_idr_iplddt_scores = [\n\t\tiplddt\n\t\tfor chain_id, iplddt_scores in self.per_chain_iplddt.items()\n\t\tfor iplddt in iplddt_scores.values()\n\t\tif chain_id in self.idr_chains\n\t]\n\n\toverall_assessment[\"avg_idr_iplddt\"] = (\n\t\tnp.mean(global_idr_iplddt_scores) if global_idr_iplddt_scores else np.nan\n\t)\n\n\tglobal_ipae_ij_scores = [\n\t\tipae\n\t\tfor ipae_dict in self.pairwise_ipae.values()\n\t\tfor ipae in ipae_dict[\"ij\"].values()\n\t]\n\n\tglobal_ipae_ji_scores = [\n\t\tipae\n\t\tfor ipae_dict in self.pairwise_ipae.values()\n\t\tfor ipae in ipae_dict[\"ji\"].values()\n\t]\n\n\toverall_assessment[\"avg_ipae_ij\"] = (\n\t\tnp.mean(global_ipae_ij_scores) if global_ipae_ij_scores else np.nan\n\t)\n\n\toverall_assessment[\"avg_ipae_ji\"] = (\n\t\tnp.mean(global_ipae_ji_scores) if global_ipae_ji_scores else np.nan\n\t)\n\n\treturn overall_assessment\n```","x":-919,"y":521,"width":975,"height":1576,"color":"3"},
		{"alias":"predict_domains","collapsed":true,"id":"3f2a570e7a316dd6","type":"text","text":"```py\ndef predict_domains(\n\tself,\n\tnum_res: int = 1,\n\tnum_proteins: int = 1,\n\tplddt_filter: bool = True\n):\n\t\"\"\"Predict domains from a PAE file.\n\t- Three implementations are available:\n\t\t1. igraph based\n\t\t2. networkx based\n\t\t3. label_propagation based\n\n\t(1) is significantly faster than (2)\n\n\tArgs:\n\t\tnum_res (int): Minimum number of residues in a rigid body\n\t\tnum_proteins (int): Minimum number of proteins in a rigid body\n\t\tplddt_filter (bool): Filter the residues based on the pLDDT cutoff\n\n\tRaises:\n\t\tValueError: Invalid library specified. Use 'igraph' or 'networkx'\n\n\tReturns:\n\t\tdomains (list): List of domains in which each domain is a rigid body dictionary\n\n\tA rigid body dictionary is of the form:\n\t- {\n\t\tch1: [res_num, ...],\n\t\tch2: [res_num, ...],\n\t\t...\n\t}\n\t\"\"\"\n\n\tprint(\"Predicting domains...\")\n\tstart_time = time.time()\n\n\tpae_matrix = self.pae\n\n\tif self.library == \"igraph\":\n\t\tf = domains_from_pae_matrix_igraph\n\n\telif self.library == \"networkx\":\n\t\tf = domains_from_pae_matrix_networkx\n\n\telif self.library == \"label_propagation\":\n\t\tf = domains_from_pae_matrix_label_propagation\n\n\telse:\n\t\traise ValueError(\"Invalid library specified. Use 'igraph' or 'networkx\")\n\n\tif f == domains_from_pae_matrix_igraph or f == domains_from_pae_matrix_networkx:\n\t\tdomains = f(\n\t\t\tpae_matrix,\n\t\t\tpae_power=self.pae_power,\n\t\t\tpae_cutoff=self.pae_cutoff,\n\t\t\tgraph_resolution=self.resolution,\n\t\t)\n\telif f == domains_from_pae_matrix_label_propagation:\n\t\tdomains = f(\n\t\t\tpae_matrix,\n\t\t\tpae_power=self.pae_power,\n\t\t\tpae_cutoff=self.pae_cutoff,\n\t\t\trandom_seed=self.random_seed,\n\t\t)\n\n\t# domains is a list of frozensets or lists\n\t# each frozenset/list contains residue indices for residues in a domain\n\tfor idx, domain in enumerate(domains):\n\n\t\tif isinstance(domain, frozenset):\n\t\t\tdomain = list(domain)\n\n\t\t# rb_dict is a dictionary of rigid bodies\n\t\t# each rigid body is represented as a dictionary with chain_id as the key and a list of residue numbers as the value\n\t\trb_dict = self.domain_to_rb_dict(domain=domain)\n\n\t\t# removing residues with pLDDT score below the cutoff\n\t\tif plddt_filter:\n\t\t\trb_dict = self.filter_plddt(\n\t\t\t\trb_dict=rb_dict,\n\t\t\t\tpatch_threshold=self.patch_threshold,\n\t\t\t)\n\n\t\tdomains[idx] = rb_dict\n\n\t# Remove domains with number of proteins less than `num_proteins`\n\tdomains = [\n\t\trb_dict\n\t\tfor rb_dict in domains\n\t\tif len(rb_dict) >= num_proteins\n\t]\n\n\t# Remove domains with number of residues less than `num_res`\n\tdomains = [\n\t\trb_dict\n\t\tfor rb_dict in domains\n\t\tif sum([len(res_list) for res_list in rb_dict.values()]) >= num_res\n\t]\n\n\tend_time = time.time()\n\tprint(f\"Done predicting pseudo-rigid domains in {end_time - start_time:.2f} seconds\")\n\n\treturn domains\n```","x":-919,"y":-954,"width":1162,"height":1355,"color":"3"},
		{"alias":"domain_to_rb_dict","collapsed":true,"id":"36628ccfe51e2949","type":"text","text":"```py\ndef domain_to_rb_dict(self, domain: list):\n\t\"\"\"Convert the domain list to a dictionary of rigid bodies.\n\t- The rigid bodies are represented as a dictionary with chain_id as the key and\n\t\ta list of residue numbers as the value.\n\n\tArgs:\n\t\tdomain (list): list of residue indices in the domain\n\n\tReturns:\n\t\trb_dict (dict): pseudo-rigid body in the form of a dictionary\n\n\tExample:\n\t\tif predicted structure has chains: A (20 aa), B (30 aa), C (50 aa) \\n\n\t\tsuch that, actual residue numbers are\n\t\tA: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39] \\n\n\t\tB: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] \\n\n\t\tC: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] \\n\n\t\tand detected domain is [0, 1, 2, 3, 4, 5, 20, 21, 22, 23, 54, 55, 56, 57, 58] \\n\n\t\trb_dict = {\n\t\t\t'A': [20, 21, 22, 23, 24, 25],\n\t\t\t'B': [20, 21, 22, 23, 24],\n\t\t\t'C': [5, 6, 7, 8, 9]\n\t\t}\n\t\"\"\"\n\n\trb_dict = defaultdict(list)\n\n\tfor res_idx in domain:\n\n\t\tres_num = self.idx_to_num[res_idx].get(\"res_num\")\n\t\tchain_id = self.idx_to_num[res_idx].get(\"chain_id\")\n\n\t\trb_dict[chain_id].append(res_num)\n\n\treturn rb_dict\n```","x":-919,"y":-899,"width":955,"height":878,"color":"3"},
		{"alias":"fill_up_entity","collapsed":true,"id":"17b21d3b5fc73722","type":"file","file":"af_pipeline/AFInput/Entity/fill_up_entity.md","x":-491,"y":-3394,"width":666,"height":288,"color":"3"},
		{"alias":"create_af_sequence","collapsed":true,"id":"9c8fa18a182294ab","type":"file","file":"af_pipeline/AFInput/AFSequence/create_af_sequence.md","x":-489,"y":-3277,"width":764,"height":1336,"color":"3"},
		{"alias":"update_real_sequence","collapsed":true,"id":"82ebbd4f51c3bab4","type":"file","file":"af_pipeline/AFInput/AFSequence/update_real_sequence.md","x":-491,"y":-3206,"width":761,"height":505,"color":"3"},
		{"alias":"get_name_fragment","collapsed":true,"id":"d6c18f9f7cd3469c","type":"file","file":"af_pipeline/AFInput/AFSequence/get_name_fragment.md","x":-489,"y":-3142,"width":668,"height":257,"color":"3"},
		{"alias":"get_glycans","collapsed":true,"id":"70448a80a584905d","type":"file","file":"af_pipeline/AFInput/Entity/get_glycans.md","x":-489,"y":-3776,"width":791,"height":499,"color":"3"},
		{"alias":"get_modifications","collapsed":true,"id":"48b5d70aa8d6ebe0","type":"file","file":"af_pipeline/AFInput/Entity/get_modifications.md","x":-489,"y":-3716,"width":903,"height":915,"color":"3"},
		{"alias":"sanity_check_entity_type","collapsed":true,"id":"f631fbeabd550de4","type":"file","file":"af_pipeline/AFInput/Entity/sanity_check_entity_type.md","x":-491,"y":-3645,"width":752,"height":265,"color":"3"},
		{"collapsed":true,"id":"d5d77e9a9b21a865","type":"file","file":"af_pipeline/AFInput/Entity/sanity_check_small_molecule.md","alias":"sanity_check_small_molecule","x":-491,"y":-3576,"width":669,"height":272,"color":"3"},
		{"collapsed":true,"id":"4e76dec479353bbe","type":"file","file":"af_pipeline/AFInput/Entity/sanity_check_glycans.md","alias":"sanity_check_glycans","x":-491,"y":-3516,"width":883,"height":502,"color":"3"},
		{"alias":"sanity_check_modifcations","collapsed":true,"id":"80d653ab2498c15a","type":"file","file":"af_pipeline/AFInput/Entity/sanity_check_modifications.md","x":-491,"y":-3456,"width":991,"height":1120,"color":"3"},
		{"alias":"AFInput.Entity","collapsed":true,"id":"896a3faf0aaea00b","type":"file","file":"af_pipeline/AFInput/Entity/Entity.md","x":-1531,"y":-3917,"width":800,"height":551,"color":"5"},
		{"id":"d5ce8a306580eeae","type":"text","text":"entities_map","collapsed":true,"alias":"entities_map","x":-2171,"y":-3912,"width":250,"height":140},
		{"alias":"jobs_info","collapsed":true,"id":"602daa4f20f8672c","type":"text","text":"jobs_info","x":-2171,"y":-3759,"width":250,"height":140},
		{"alias":"entity_info","collapsed":true,"id":"1e881a2185dee5d5","type":"text","text":"entity_info","x":-2171,"y":-3599,"width":250,"height":140},
		{"id":"facb8bde9bb9c68d","type":"file","file":"af_pipeline/AFInput/AFSequence/AFSequence.md","collapsed":true,"alias":"AFInput.AFSequence","x":-1531,"y":-3466,"width":800,"height":360,"color":"5"},
		{"collapsed":true,"id":"35939b739cd8231b","type":"file","file":"af_pipeline/AFInput/AFCycle/AFCycle.md","alias":"AFInput.AFCycle","x":-1531,"y":-4700,"width":800,"height":354,"color":"5"},
		{"id":"0394765f9b558e2e","type":"text","text":"nucleic_acid_sequences","alias":"nucleic_acid_sequences","collapsed":true,"x":-2171,"y":-4372,"width":250,"height":140},
		{"collapsed":true,"id":"0d2475af927ffe18","type":"file","file":"af_pipeline/AFInput/AFJob/AFJob.md","alias":"AFInput.AFJob","x":-1531,"y":-4347,"width":800,"height":420,"color":"5"},
		{"id":"16dd492c252dbc5b","type":"text","text":"input_yml\n","alias":"input_yml","collapsed":true,"x":-2171,"y":-4232,"width":250,"height":140},
		{"id":"fb31e7fd80d0c1c3","type":"text","text":"protein_sequences","alias":"protein_sequences","collapsed":true,"x":-2171,"y":-4074,"width":250,"height":140},
		{"alias":"update_cycle","collapsed":true,"id":"722c8d7bdaa4e0bf","type":"file","file":"af_pipeline/AFInput/AFCycle/update_cycle.md","x":-489,"y":-4741,"width":804,"height":474,"color":"3"},
		{"alias":"seed_jobs","collapsed":true,"id":"3a3d7f7b75f8f1d0","type":"file","file":"af_pipeline/AFInput/AFCycle/seed_jobs.md","x":-489,"y":-4666,"width":662,"height":905,"color":"3"},
		{"alias":"create_job","collapsed":true,"id":"a6da96bb5a33e98b","type":"file","file":"af_pipeline/AFInput/AFJob/create_job.md","x":-489,"y":-4523,"width":661,"height":650,"color":"3"},
		{"alias":"update_job_name","collapsed":true,"id":"6e1bc1aebc8fcfe3","type":"file","file":"af_pipeline/AFInput/AFJob/update_job_name.md","x":-489,"y":-4446,"width":522,"height":198,"color":"3"},
		{"alias":"update_model_seeds","collapsed":true,"id":"6057e6c6b970fac8","type":"file","file":"af_pipeline/AFInput/AFJob/update_model_seeds.md","x":-489,"y":-4366,"width":799,"height":593,"color":"3"},
		{"alias":"get_entity_range","collapsed":true,"id":"cbe0ed4d4ee75c15","type":"file","file":"af_pipeline/AFInput/Entity/get_entity_range.md","x":-489,"y":-3843,"width":743,"height":660,"color":"3"},
		{"alias":"update_af_sequences","collapsed":true,"id":"af1b07df21a158f9","type":"file","file":"af_pipeline/AFInput/AFJob/update_af_sequences.md","x":-489,"y":-4286,"width":877,"height":502,"color":"3"},
		{"alias":"generate_job_name","collapsed":true,"id":"efb5ec3cb9519154","type":"file","file":"af_pipeline/AFInput/AFJob/generate_job_name.md","x":-489,"y":-4218,"width":489,"height":230,"color":"3"},
		{"collapsed":true,"id":"9ccff1d61dc7f952","type":"file","file":"af_pipeline/AFInput/AFJob/generate_seeds.md","alias":"generate_seeds","x":-489,"y":-4149,"width":819,"height":256,"color":"3"},
		{"alias":"get_template_settings","collapsed":true,"id":"910261550e5f7179","type":"file","file":"af_pipeline/AFInput/Entity/get_template_settings.md","x":-489,"y":-4039,"width":1228,"height":762,"color":"3"},
		{"alias":"get_entity_count","collapsed":true,"id":"03326850c9af3a9b","type":"file","file":"af_pipeline/AFInput/Entity/get_entity_count.md","x":-489,"y":-3976,"width":649,"height":307,"color":"3"},
		{"alias":"get_real_sequence","collapsed":true,"id":"81fd5856a0308d86","type":"file","file":"af_pipeline/AFInput/Entity/get_real_sequence.md","x":-489,"y":-3916,"width":875,"height":1026,"color":"3"},
		{"alias":"write_to_json","collapsed":true,"id":"2951fca6224f4d3a","type":"file","file":"af_pipeline/AFInput/AlphaFold3/write_to_json.md","x":-4398,"y":-4389,"width":967,"height":583,"color":"3"},
		{"alias":"create_af3_job_cycles","collapsed":true,"id":"cd9323c424f0687c","type":"file","file":"af_pipeline/AFInput/AlphaFold3/create_af3_job_cycles.md","x":-4111,"y":-4309,"width":680,"height":720,"color":"3"},
		{"alias":"write_job_files","collapsed":true,"id":"9b86007a6db3a207","type":"file","file":"af_pipeline/AFInput/AlphaFold3/write_job_files.md","x":-4491,"y":-4229,"width":1060,"height":729,"color":"3"},
		{"alias":"create_colabfold_job_cycles","collapsed":true,"id":"e3af8704a7bd6db1","type":"file","file":"af_pipeline/AFInput/ColabFold/create_colabfold_job_cycles.md","x":-4213,"y":-4071,"width":782,"height":742,"color":"3"},
		{"id":"790310232fc8dd02","type":"file","file":"af_pipeline/AFInput/ColabFold/ColabFold.md","alias":"AFInput.ColabFold","collapsed":true,"x":-3227,"y":-3946,"width":800,"height":297,"color":"5"},
		{"alias":"AFInput.AlphaFold2","id":"ca4833989cdda68f","type":"file","file":"af_pipeline/AFInput/AlphaFold2/AlphaFold2.md","collapsed":true,"x":-3227,"y":-3725,"width":800,"height":461,"color":"5"},
		{"alias":"create_af2_job_cycles","collapsed":true,"id":"490e6fce755ebfbf","type":"file","file":"af_pipeline/AFInput/AlphaFold2/create_af2_job_cycles.md","x":-4232,"y":-3909,"width":801,"height":661,"color":"3"},
		{"alias":"write_to_fasta","collapsed":true,"id":"530050779764c58a","type":"file","file":"af_pipeline/AFInput/AlphaFold2/write_to_fasta.md","x":-4376,"y":-3824,"width":945,"height":576,"color":"3"},
		{"alias":"write_job_files","collapsed":true,"id":"d50e37ae73697645","type":"file","file":"af_pipeline/AFInput/AlphaFold2/write_job_files.md","x":-4165,"y":-3750,"width":734,"height":609,"color":"3"},
		{"alias":"generate_job_entiteis","collapsed":true,"id":"215a2f86349a64eb","type":"file","file":"af_pipeline/AFInput/AlphaFold2/generate_job_entities.md","x":-4253,"y":-3679,"width":822,"height":1430,"color":"3"},
		{"alias":"get_entity_info","collapsed":true,"id":"4d53668218846822","type":"file","file":"af_pipeline/AFInput/AlphaFold2/get_entity_info.md","x":-4332,"y":-3609,"width":901,"height":622,"color":"3"},
		{"alias":"get_entity_sequences","collapsed":true,"id":"918c41f11bb305b6","type":"file","file":"af_pipeline/AFInput/AlphaFold2/get_entity_sequences.md","x":-4261,"y":-3529,"width":830,"height":908,"color":"3"},
		{"alias":"generate_job_name","collapsed":true,"id":"0009191feb415414","type":"file","file":"af_pipeline/AFInput/AlphaFold2/generate_job_name.md","x":-4214,"y":-3449,"width":783,"height":849,"color":"3"},
		{"alias":"warning_not_protein","collapsed":true,"id":"568de8dd00263a45","type":"file","file":"af_pipeline/AFInput/AlphaFold2/warning_not_protein.md","x":-4250,"y":-3370,"width":819,"height":689,"color":"3"},
		{"id":"255c5f0d9ee87b77","type":"file","file":"af_pipeline/AFInput/AlphaFold3/AlphaFold3.md","alias":"AFInput.AlphaFold3","collapsed":true,"x":-3227,"y":-4170,"width":800,"height":400,"color":"5"}
	],
	"edges":[
		{"id":"abb74e18599754fa","fromNode":"50170a2e5fddc142","fromSide":"right","toNode":"3f2a570e7a316dd6","toSide":"left"},
		{"id":"0e191e4f773cca4b","fromNode":"50170a2e5fddc142","fromSide":"right","toNode":"36628ccfe51e2949","toSide":"left"},
		{"id":"3a8898f0472513e2","fromNode":"50170a2e5fddc142","fromSide":"right","toNode":"ab2b183971db89c7","toSide":"left"},
		{"id":"7e52a12dd6f00d96","fromNode":"50170a2e5fddc142","fromSide":"right","toNode":"91dc4275aa5beb82","toSide":"left"},
		{"id":"debee0aac75af132","fromNode":"50170a2e5fddc142","fromSide":"right","toNode":"a0c5358863c438d1","toSide":"left"},
		{"id":"12c065710bb9a78d","fromNode":"50170a2e5fddc142","fromSide":"bottom","toNode":"f903b8ed5a2c17ac","toSide":"top","color":"#000000","label":"has a"},
		{"id":"0530ca6860746f1f","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"c9cf8d4b8e6b7a5a","toSide":"left"},
		{"id":"70a5b0968e89c8dd","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"017a1b44699d1497","toSide":"left"},
		{"id":"caa0d763e4c8ba0e","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"454d0aa6a0db65a7","toSide":"left"},
		{"id":"bbfe9ba5c1513b77","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"9670c32e6dec70e8","toSide":"left"},
		{"id":"cb49a9c22c16e093","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"17f88e2ededc532f","toSide":"left"},
		{"id":"4c2058f6c0ae65a0","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"a64e26126101120b","toSide":"left"},
		{"id":"1a11309ee8244271","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"77a43d29d2a2db4c","toSide":"left"},
		{"id":"f1f16691eb36874c","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"f22183525769e578","toSide":"left"},
		{"id":"32a25c9a9003e40f","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"64da089e2309156e","toSide":"left"},
		{"id":"820c55c2c234f2c5","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"1d5072fdcf17c7c9","toSide":"left"},
		{"id":"8a216af7f7de151e","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"b81fd2fba386812e","toSide":"left"},
		{"id":"c14462483f817c42","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"5f3184d9b368f615","toSide":"left"},
		{"id":"23a1124156729c10","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"196d5dbfb56f35c0","toSide":"left"},
		{"id":"86b149760ad97792","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"7c93f583f3c8e398","toSide":"left"},
		{"id":"11e6ae30fc4511d7","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"0ba26850061961b8","toSide":"left"},
		{"id":"e07cbf4ab793c3b8","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"0303f761ebdcb514","toSide":"left"},
		{"id":"3b536c488031db54","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"d566466180d9574b","toSide":"left"},
		{"id":"6a85dad33eb7ed2e","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"f038790f1222ec79","toSide":"left"},
		{"id":"16c7f59aee4801bc","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"d568fcad1a5ea0ae","toSide":"left"},
		{"id":"1c5340345304d98c","fromNode":"f903b8ed5a2c17ac","fromSide":"right","toNode":"25e23fe01c2facf1","toSide":"left"},
		{"id":"665e95475102715e","fromNode":"0394765f9b558e2e","fromSide":"right","toNode":"35939b739cd8231b","toSide":"left"},
		{"id":"050de8361b26910c","fromNode":"0394765f9b558e2e","fromSide":"right","toNode":"0d2475af927ffe18","toSide":"left"},
		{"id":"32625e8f8584c368","fromNode":"0394765f9b558e2e","fromSide":"right","toNode":"facb8bde9bb9c68d","toSide":"left"},
		{"id":"c44cde56d72f90f5","fromNode":"0394765f9b558e2e","fromSide":"left","toNode":"255c5f0d9ee87b77","toSide":"right"},
		{"id":"6902562bb463fb56","fromNode":"fb31e7fd80d0c1c3","fromSide":"right","toNode":"35939b739cd8231b","toSide":"left"},
		{"id":"4f818c85ace082c3","fromNode":"fb31e7fd80d0c1c3","fromSide":"right","toNode":"0d2475af927ffe18","toSide":"left"},
		{"id":"f44def3ddc8567dc","fromNode":"fb31e7fd80d0c1c3","fromSide":"right","toNode":"facb8bde9bb9c68d","toSide":"left"},
		{"id":"e14b135071f4f420","fromNode":"fb31e7fd80d0c1c3","fromSide":"left","toNode":"255c5f0d9ee87b77","toSide":"right"},
		{"id":"689746edc42c21b4","fromNode":"fb31e7fd80d0c1c3","fromSide":"left","toNode":"790310232fc8dd02","toSide":"right"},
		{"id":"de32ea025588d361","fromNode":"fb31e7fd80d0c1c3","fromSide":"left","toNode":"ca4833989cdda68f","toSide":"right"},
		{"id":"5eb251533068f6a7","fromNode":"d5ce8a306580eeae","fromSide":"right","toNode":"35939b739cd8231b","toSide":"left"},
		{"id":"b103317fd36edcfb","fromNode":"d5ce8a306580eeae","fromSide":"right","toNode":"0d2475af927ffe18","toSide":"left"},
		{"id":"98a4e22f14dd6c16","fromNode":"d5ce8a306580eeae","fromSide":"right","toNode":"facb8bde9bb9c68d","toSide":"left"},
		{"id":"6217820ae709448e","fromNode":"d5ce8a306580eeae","fromSide":"left","toNode":"790310232fc8dd02","toSide":"right"},
		{"id":"5ac8cda0d2b09ab6","fromNode":"d5ce8a306580eeae","fromSide":"left","toNode":"ca4833989cdda68f","toSide":"right"},
		{"id":"8952923e7ad5bfd1","fromNode":"d5ce8a306580eeae","fromSide":"left","toNode":"255c5f0d9ee87b77","toSide":"right"},
		{"id":"b9de2e87b1ccc611","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"215a2f86349a64eb","toSide":"right"},
		{"id":"1b3ccee06992e1b3","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"4d53668218846822","toSide":"right"},
		{"id":"058dbc2022af864e","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"918c41f11bb305b6","toSide":"right"},
		{"id":"841fe6f4fe9aa2e5","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"0009191feb415414","toSide":"right"},
		{"id":"d36d1a7a2b925716","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"568de8dd00263a45","toSide":"right"},
		{"id":"b6220ace4f11484e","fromNode":"602daa4f20f8672c","fromSide":"right","toNode":"35939b739cd8231b","toSide":"left"},
		{"id":"89c0b2a44f890ef0","fromNode":"602daa4f20f8672c","fromSide":"right","toNode":"0d2475af927ffe18","toSide":"left"},
		{"id":"48fc89cef2f2b685","fromNode":"1e881a2185dee5d5","fromSide":"right","toNode":"facb8bde9bb9c68d","toSide":"left"},
		{"id":"ef96b33c371b2728","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"d50e37ae73697645","toSide":"right"},
		{"id":"281c9eed18399405","fromNode":"255c5f0d9ee87b77","fromSide":"left","toNode":"cd9323c424f0687c","toSide":"right"},
		{"id":"cb8d8e87ca3b2369","fromNode":"790310232fc8dd02","fromSide":"left","toNode":"e3af8704a7bd6db1","toSide":"right"},
		{"id":"cae3d09e678b36f7","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"490e6fce755ebfbf","toSide":"right"},
		{"id":"5b631f79f7b0b9c9","fromNode":"ca4833989cdda68f","fromSide":"left","toNode":"530050779764c58a","toSide":"right"},
		{"id":"bb0a2968a531af38","fromNode":"255c5f0d9ee87b77","fromSide":"left","toNode":"2951fca6224f4d3a","toSide":"right"},
		{"id":"763f65e6e5b6a6d3","fromNode":"255c5f0d9ee87b77","fromSide":"left","toNode":"9b86007a6db3a207","toSide":"right"},
		{"id":"b3e116f69ba62266","fromNode":"facb8bde9bb9c68d","fromSide":"right","toNode":"9c8fa18a182294ab","toSide":"left"},
		{"id":"54b09b5c462fd897","fromNode":"facb8bde9bb9c68d","fromSide":"right","toNode":"82ebbd4f51c3bab4","toSide":"left"},
		{"id":"1b6418331a6d6c72","fromNode":"facb8bde9bb9c68d","fromSide":"right","toNode":"d6c18f9f7cd3469c","toSide":"left"},
		{"id":"50b4a5fb1807fb8e","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"a6da96bb5a33e98b","toSide":"left"},
		{"id":"c1260c5005bc7123","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"6e1bc1aebc8fcfe3","toSide":"left"},
		{"id":"8335b4b85ea56347","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"6057e6c6b970fac8","toSide":"left"},
		{"id":"0591b1215befb4ee","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"af1b07df21a158f9","toSide":"left"},
		{"id":"507c81932e2f8162","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"efb5ec3cb9519154","toSide":"left"},
		{"id":"4a7be6e8f846977d","fromNode":"0d2475af927ffe18","fromSide":"right","toNode":"9ccff1d61dc7f952","toSide":"left"},
		{"id":"51771d6bd31b7a57","fromNode":"790310232fc8dd02","fromSide":"bottom","toNode":"ca4833989cdda68f","toSide":"top","color":"#000000","label":"is a"},
		{"id":"c2035e0285fba4a2","fromNode":"16dd492c252dbc5b","fromSide":"left","toNode":"ca4833989cdda68f","toSide":"right"},
		{"id":"e115e6a5bc78b40b","fromNode":"16dd492c252dbc5b","fromSide":"left","toNode":"790310232fc8dd02","toSide":"right"},
		{"id":"2ffc4b23c3b7783c","fromNode":"35939b739cd8231b","fromSide":"bottom","toNode":"0d2475af927ffe18","toSide":"top","color":"#000000","label":"has a"},
		{"id":"d8a4c58b82411b78","fromNode":"255c5f0d9ee87b77","fromSide":"top","toNode":"35939b739cd8231b","toSide":"left","color":"#000000","label":"has a"},
		{"id":"5e89395f2121779f","fromNode":"16dd492c252dbc5b","fromSide":"left","toNode":"255c5f0d9ee87b77","toSide":"right"},
		{"id":"364162dd870f89c6","fromNode":"0fba078d74296741","fromSide":"right","toNode":"d67b3c7391abb2d1","toSide":"left"},
		{"id":"1ee157abbae532b4","fromNode":"0fba078d74296741","fromSide":"right","toNode":"7118114a0767f034","toSide":"left"},
		{"id":"676290f23cdeac83","fromNode":"0fba078d74296741","fromSide":"right","toNode":"cfdc8495c0f80a06","toSide":"left"},
		{"id":"4c14282427345ecb","fromNode":"0fba078d74296741","fromSide":"right","toNode":"ef316634bc0c8b8c","toSide":"left"},
		{"id":"e8f5e2d36c7e56b7","fromNode":"0fba078d74296741","fromSide":"right","toNode":"dd644e1e90c8a2d3","toSide":"left"},
		{"id":"0561134ffd679433","fromNode":"0fba078d74296741","fromSide":"right","toNode":"2f73dbf7e691bb21","toSide":"left"},
		{"id":"60623d52f14d4c52","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"d2c4c77458467049","toSide":"left"},
		{"id":"be2c4f8f57e6ba74","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"89253dba6a6ed415","toSide":"left"},
		{"id":"6ea64d45fc6ff97e","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"2f1b179777efd10c","toSide":"left"},
		{"id":"f0a637a404b154b5","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"c9499d90e7fdf845","toSide":"left"},
		{"id":"304d309f0f4d5a25","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"dff8949bbb70453a","toSide":"left"},
		{"id":"00bb0a33d03917e0","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"fa3fbcd999faba43","toSide":"left"},
		{"id":"580a170aac7d5800","fromNode":"4ec6c15d90feabff","fromSide":"right","toNode":"9c59f535d25a6880","toSide":"left"},
		{"id":"a94210d965459120","fromNode":"0fba078d74296741","fromSide":"bottom","toNode":"4ec6c15d90feabff","toSide":"top","color":"#000000","label":"has a"},
		{"id":"eaf4759546db8082","fromNode":"02052820abfcae00","fromSide":"right","toNode":"696bb2ec4b794453","toSide":"left"},
		{"id":"66b32e2248fda738","fromNode":"02052820abfcae00","fromSide":"right","toNode":"696bb2ec4b794453","toSide":"left"},
		{"id":"89ae794203b00df1","fromNode":"02052820abfcae00","fromSide":"right","toNode":"72d276fc1f52cd23","toSide":"left"},
		{"id":"9b4f327a03ad9590","fromNode":"02052820abfcae00","fromSide":"right","toNode":"c102197206cb9ffd","toSide":"left"},
		{"id":"f9e468520cbba10c","fromNode":"02052820abfcae00","fromSide":"right","toNode":"ff30e281989fbee9","toSide":"left"},
		{"id":"6b08ba184f04b06c","fromNode":"02052820abfcae00","fromSide":"right","toNode":"41539ad4a45137dd","toSide":"left"},
		{"id":"fc8fa5113b4c25ce","fromNode":"02052820abfcae00","fromSide":"right","toNode":"8034d0e8bac48270","toSide":"left"},
		{"id":"9aa13463506c3504","fromNode":"02052820abfcae00","fromSide":"right","toNode":"af99bf2d1f265fdf","toSide":"left"},
		{"id":"7edb104ebbbda0d4","fromNode":"02052820abfcae00","fromSide":"right","toNode":"5dfbc8222ba08755","toSide":"left"},
		{"id":"6bdd4d6fc0da23f5","fromNode":"02052820abfcae00","fromSide":"right","toNode":"b469e5b1d3b488bd","toSide":"left"},
		{"id":"96dd8f066dfb3b7a","fromNode":"7597227871dc4aed","fromSide":"left","toNode":"97147b0f899e7074","toSide":"right"},
		{"id":"6d34bea94ddb61ea","fromNode":"7597227871dc4aed","fromSide":"left","toNode":"6c09a2b027488544","toSide":"right"},
		{"id":"eceb0f1eb28c31ac","fromNode":"7597227871dc4aed","fromSide":"left","toNode":"90fe787799ddf310","toSide":"right"},
		{"id":"66a833bb2f40f237","fromNode":"7597227871dc4aed","fromSide":"left","toNode":"b5581c496d149602","toSide":"right"},
		{"id":"065f4847b15c5cbb","fromNode":"0fba078d74296741","fromSide":"left","toNode":"7597227871dc4aed","toSide":"right","color":"#000000","label":"has a"},
		{"id":"cfb0baa01a79bd72","fromNode":"f06f13c367c07676","fromSide":"right","toNode":"7cc5c3b46b7646e5","toSide":"left"},
		{"id":"adfdbac118d46185","fromNode":"0fba078d74296741","fromSide":"top","toNode":"02052820abfcae00","toSide":"bottom","color":"#000000","label":"has a"},
		{"id":"fbe6a5e7e79c7482","fromNode":"e2c2bd72e53bb5a8","fromSide":"right","toNode":"6db7996ab0c1715d","toSide":"left"},
		{"id":"cbc30568e36e60ca","fromNode":"e2c2bd72e53bb5a8","fromSide":"right","toNode":"6939e925e7239b44","toSide":"left"},
		{"id":"60ee64b62f0c71e3","fromNode":"35939b739cd8231b","fromSide":"right","toNode":"3a3d7f7b75f8f1d0","toSide":"left"},
		{"id":"0231247a54fd3053","fromNode":"35939b739cd8231b","fromSide":"right","toNode":"722c8d7bdaa4e0bf","toSide":"left"},
		{"id":"b3634c37ae51f60a","fromNode":"0394765f9b558e2e","fromSide":"right","toNode":"896a3faf0aaea00b","toSide":"left"},
		{"id":"eef3c848bd2d9ce5","fromNode":"fb31e7fd80d0c1c3","fromSide":"right","toNode":"896a3faf0aaea00b","toSide":"left"},
		{"id":"6bd485be8b06cbab","fromNode":"d5ce8a306580eeae","fromSide":"right","toNode":"896a3faf0aaea00b","toSide":"left"},
		{"id":"d60fe55bfb1372de","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"17b21d3b5fc73722","toSide":"left"},
		{"id":"f28e762cb6374ecc","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"910261550e5f7179","toSide":"left"},
		{"id":"61aee3a5cd79aedc","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"03326850c9af3a9b","toSide":"left"},
		{"id":"9b5d25226ab8b171","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"81fd5856a0308d86","toSide":"left"},
		{"id":"043cfd49b6faf76a","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"cbe0ed4d4ee75c15","toSide":"left"},
		{"id":"b9b9f5fa36494357","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"70448a80a584905d","toSide":"left"},
		{"id":"3931361284da2232","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"48b5d70aa8d6ebe0","toSide":"left"},
		{"id":"5a785748855ba209","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"f631fbeabd550de4","toSide":"left"},
		{"id":"b5de3ca3e406c9ec","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"d5d77e9a9b21a865","toSide":"left"},
		{"id":"2ac7af6dda3c1c62","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"4e76dec479353bbe","toSide":"left"},
		{"id":"253087161555bf99","fromNode":"896a3faf0aaea00b","fromSide":"right","toNode":"80d653ab2498c15a","toSide":"left"},
		{"id":"50e9975771a6c4eb","fromNode":"0d2475af927ffe18","fromSide":"bottom","toNode":"896a3faf0aaea00b","toSide":"top","color":"#000000","label":"has a"},
		{"id":"e4e284524152a7b4","fromNode":"facb8bde9bb9c68d","fromSide":"top","toNode":"896a3faf0aaea00b","toSide":"bottom","color":"#000000","label":"is a"},
		{"id":"9a8631810837e0a1","fromNode":"50170a2e5fddc142","fromSide":"top","toNode":"e2c2bd72e53bb5a8","toSide":"bottom","color":"#000000","label":"is a"},
		{"id":"21a27338e03bd0f7","fromNode":"8d39257a9640ecf5","fromSide":"top","toNode":"e2c2bd72e53bb5a8","toSide":"bottom","color":"#000000","label":"is a"},
		{"id":"0e4c2f3d650d7eee","fromNode":"e2c2bd72e53bb5a8","fromSide":"top","toNode":"0fba078d74296741","toSide":"left","color":"#000000","label":"is a"},
		{"id":"11ec143e3a3d0849","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"60e56fb5cf97166b","toSide":"right"},
		{"id":"17455ebe96879efa","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"a2eea1af3c990ff5","toSide":"right"},
		{"id":"5af0c81240079d91","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"9289ab605522ff99","toSide":"right"},
		{"id":"59c893d2d1c584bf","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"394f3b85731dbd32","toSide":"right"},
		{"id":"7cc09ef057a02bc9","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"4e65eace47c4628e","toSide":"right"},
		{"id":"2013df1e4b96139b","fromNode":"8d39257a9640ecf5","fromSide":"left","toNode":"bc3b91e24f1ccfab","toSide":"right"}
	]
}